/* Generated By:JavaCC: Do not edit this line. AxionSqlParser.java */
package org.axiondb.parser;

import org.axiondb.*;
import org.axiondb.constraints.*;
import org.axiondb.types.*;
import org.axiondb.functions.*;
import org.axiondb.engine.commands.*;

import java.io.StringReader;

import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.math.BigDecimal;

/**
 * JavaCC generated SQL parser.
 * Generated from AxionSqlParser.jj ().
 * Do not edit this (.java) file directly, it is programmaticly generated.
 *
 * @author kevinh (at) empower.com.au
 * @author Doug Sale
 * @author Chuck Burdick
 * @author Rodney Waldhoff
 * @author James Strachan
 * @author Rob Oxspring
 * @author Amrish Lal
 * @author Rahul Dwivedi
 * @author Dave Pekarek Krohn
 * @author Ahimanikya Satapathy
 * @author Jonathan Giron
 * @author Ritesh Adval
 */
public class AxionSqlParser implements Parser, AxionSqlParserConstants {

    public AxionSqlParser() {
        this(new StringReader(""));
        _log.log(Level.FINE,"created new parser");
    }

    public AxionCommand parse(String sql) throws AxionException {
        this.ReInit(new StringReader(sql));

        try {
            return this.SqlCommand();
        } catch (TokenMgrError e) {
            throw new AxionException(e);
        } catch (AxionSqlParseException sqlEx) {
                throw sqlEx.getNestedException();
        } catch (ParseException ex) {
            throw new AxionException(ex);
        }
    }

    /**
     * Returns unique name/String in a parse session based on the function/key 
     * name. This unique name is used internally to set alias name for functions 
     * if one does not exits. So as to avoid using same name if function is used
     * more than once. 
     * Neeed to remove dependency on Alias to identify Columns in a result set.
     **/
    private String getUniqueAliasName(Map aliasSuffixCounterMap, String key){
        Object counterObj  = aliasSuffixCounterMap.get(key);
        Integer counter = null;

        if (counterObj != null){
            counter = (Integer) counterObj;
            counter = new Integer(counter.intValue() + 1);
        }else{
            counter = new Integer(0);
        }

        aliasSuffixCounterMap.put(key, counter);

        if (counter.intValue() == 0){
            return key;
        }else{
            return key + counter.intValue();
        }
    }

    static Set systemTables = new HashSet(10);
    static {
         systemTables.add("AXION_CATALOGS");
         systemTables.add("AXION_COLUMNS");
         systemTables.add("AXION_DB_LINKS");
         systemTables.add("AXION_INDEX_INFO");
         systemTables.add("AXION_SCHEMATA");
         systemTables.add("AXION_SEQUENCES");
         systemTables.add("AXION_TABLES");
         systemTables.add("AXION_TABLE_PROPERTIES");
         systemTables.add("AXION_TABLE_TYPES");
         systemTables.add("AXION_TYPES");
    }

    /** protect SYSTEM Tables **/
    private void protectSystemTable(String tableName) throws ParseException {
        if(systemTables.contains(tableName)) {
            throw new ParseException("Operation not allowed on SYSTEM tables");
        }
    }

   /**
    * Replaces all occurrences of <i>old</i> in <i>src</i> with <i>nu</i>.
    *
    * @param src the source String
    * @param old the character to replace
    * @param nu  the String to replace <i>old</i> with
    * @return a copy of <i>src</i> with all instances of <i>old</i>
    *         replaced by <i>nu</i>
    * @throws java.lang.NullPointerException if any argument is null.
    */
    private final static String replace(String src, String old, String nu) {
        int srclen = src.length();
        int cur = 0;
        int loc = 0;
        int oldlen = old.length();

        StringBuffer buf = new StringBuffer(srclen+nu.length());

        do {
            loc = src.indexOf(old,cur);
            if(loc != -1) {
                buf.append(src.substring(cur,loc));
                buf.append(nu);
                cur = loc + oldlen;
            }
        } while(loc != -1);

        if(cur < srclen) {
            buf.append(src.substring(cur));
        }

        return buf.toString();
    }

    private static Selectable makeLeafWhereNode(Selectable left, String op, Selectable right) {
        FunctionIdentifier fn = new FunctionIdentifier(op);
        fn.addArgument(left);

        if(null != right) {
            fn.addArgument(right);
        }
        return fn;
    }

    private static Logger _log = Logger.getLogger(AxionSqlParser.class.getName());

    static class AxionSqlParseException extends ParseException {
        public AxionSqlParseException() {
            super();
            _nested = new AxionException(42000);
        }

        public AxionSqlParseException(String message, int sqlState) {
                    super(message);
            _nested = new AxionException(message, sqlState);
                }

                public AxionException getNestedException() {
                        return _nested;
                }

        private AxionException _nested;
    }

    // ----------------------------------------------------------------------------
    // SQL GRAMMAR
    // ----------------------------------------------------------------------------

    // ----------------------------------------------------------------------------
    // COMMANDS
    // ----------------------------------------------------------------------------
  final public AxionCommand SqlCommand() throws ParseException {
        AxionCommand result = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXPLAIN:
    case SELECT:
      result = SqlSelect();
      break;
    case INSERT:
      result = SqlInsert();
      break;
    case UPDATE:
      result = SqlUpdate();
      break;
    case MERGE:
    case UPSERT:
      result = SqlUpsert();
      break;
    case DELETE:
      result = SqlDelete();
      break;
    case CREATE:
      result = SqlCreate();
      break;
    case DROP:
      result = SqlDrop();
      break;
    case ALTER:
      result = SqlAlterCmd();
      break;
    case ID:
      result = SqlAxionCustom();
      break;
    case DEFRAG:
      result = SQLDefrag();
      break;
    case TRUNCATE:
      result = SqlTruncate();
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SEMICOLON:
      jj_consume_token(SEMICOLON);
      break;
    default:
      ;
    }
    jj_consume_token(0);

                 _log.log(Level.FINE,"SqlCommand: created \"" + result + "\"");

             {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

    // ----------------------------------------------------------------------------
    // COMMANDS: AXION CUSTOM
    // ----------------------------------------------------------------------------
  final public AxionCommand SqlAxionCustom() throws ParseException {
        String name;
    name = SqlUnquotedId();
            if("REMOUNT".equals(name)) {
                {if (true) return SqlRemount();}
            } else if("SHUTDOWN".equals(name)) {
                {if (true) return new ShutdownCommand();}
            } else if("CHECKFILESTATE".equals(name)) {
                {if (true) return new CheckFileStateCommand();}
            } else {
                {if (true) throw new ParseException("Expected REMOUNT, " +
                      "SHUTDOWN or CHECKFILESTATE found \"" +  name + "\".");}
            }
    throw new Error("Missing return statement in function");
  }

  final public AxionCommand SqlRemount() throws ParseException {
        RemountCommand remount = new RemountCommand();
        Object dir;
        String name;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXTERNAL:
      jj_consume_token(EXTERNAL);
      jj_consume_token(TABLE);
      name = SqlUnquotedId();
                remount.setTable(new TableIdentifier(name));
                {if (true) return remount;}
      break;
    case STRING_LITERAL:
    case ID:
    case QUESTIONMARK:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        name = SqlUnquotedId();
                   remount.setTable(new TableIdentifier(name));
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DATA:
          jj_consume_token(DATA);
                       remount.setDataFilesOnly(true);
          break;
        default:
          ;
        }
        break;
      default:
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING_LITERAL:
        jj_consume_token(STRING_LITERAL);
                    // trim off the open and close quotes
                    String trimmed = token.image.substring(1, token.image.length() - 1);

                    // replace all '' with '
                    String result = replace(trimmed,"''","'");

                    dir = result;
                    remount.setDirectory(result);
        break;
      case QUESTIONMARK:
        dir = SqlBindVar();
                     remount.setDirectory((Literal)dir);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
            {if (true) return remount;}
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public AxionCommand SQLDefrag() throws ParseException {
        DefragCommand defrag = new DefragCommand();
        String table = null;
    jj_consume_token(DEFRAG);
    jj_consume_token(TABLE);
    table = SqlIdentifier();
            defrag.setObjectName(table);
            {if (true) return defrag;}
    throw new Error("Missing return statement in function");
  }

    // ----------------------------------------------------------------------------
    // COMMANDS: TRUNCATE
    // ----------------------------------------------------------------------------
  final public AxionCommand SqlTruncate() throws ParseException {
        TruncateCommand trunc = new TruncateCommand();
        String table = null;
    jj_consume_token(TRUNCATE);
    jj_consume_token(TABLE);
    table = SqlIdentifier();
            protectSystemTable(table);
            trunc.setObjectName(table);
            {if (true) return trunc;}
    throw new Error("Missing return statement in function");
  }

    // ----------------------------------------------------------------------------
    // COMMANDS: CREATE
    // ----------------------------------------------------------------------------
  final public AxionCommand SqlCreate() throws ParseException {
        AxionCommand result = null;
    jj_consume_token(CREATE);
    if (jj_2_1(2)) {
      result = SqlCreateTable();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VIEW:
        result = SqlCreateView();
        break;
      case DATABASE:
        result = SqlCreateServer();
        break;
      case INDEX:
      case UNIQUE:
      case ID:
      case START_QUOTED_IDENTIFIER:
        result = SqlCreateIndex();
        break;
      case SEQUENCE:
        result = SqlCreateSequence();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public AxionCommand SqlCreateTable() throws ParseException {
        CreateTableCommand result = new CreateTableCommand();
        Properties props = null;
        AxionCommand subselect = null;
        String type = null;
        Token t = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXTERNAL:
    case ID:
    case START_QUOTED_IDENTIFIER:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXTERNAL:
        t = jj_consume_token(EXTERNAL);
                  type = t.image;
                  result.setType(type);
        break;
      case ID:
      case START_QUOTED_IDENTIFIER:
        type = SqlIdentifier();
                  result.setType(type);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      ;
    }
    jj_consume_token(TABLE);
    SqlIfNotExists(result);
            protectSystemTable(result.getObjectName());
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      subselect = SqlSubSelect();
                result.setSubQuery((SubSelectCommand)subselect);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WITH:
        if (jj_2_2(2)) {
          jj_consume_token(WITH);
          jj_consume_token(NO);
          jj_consume_token(DATA);
                        result.setCreateTableWithData(false);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WITH:
            jj_consume_token(WITH);
            jj_consume_token(DATA);
                        result.setCreateTableWithData(true);
            break;
          default:
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        ;
      }
      break;
    case OPENPAREN:
      jj_consume_token(OPENPAREN);
      SqlColumnExpression(result);
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          break label_1;
        }
        jj_consume_token(COMMA);
        SqlColumnExpression(result);
      }
      jj_consume_token(CLOSEPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ORGANIZATION:
        jj_consume_token(ORGANIZATION);
                if (!"external".equalsIgnoreCase(type)) {
                    {if (true) throw new ParseException("ORGANIZATION clause is only valid for external tables.");}
                }
        jj_consume_token(OPENPAREN);
        props = SqlReadProperties();
                    result.setProperties(props);
        jj_consume_token(CLOSEPAREN);
        break;
      default:
        ;
      }
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public AxionCommand SqlCreateView() throws ParseException {
        CreateViewCommand result = new CreateViewCommand();
        Token t = null;
    jj_consume_token(VIEW);
    SqlIfNotExists(result);
    jj_consume_token(AS);
            StringBuffer buf =  new StringBuffer();
            for(t = getNextToken();t.kind != EOF;t = getNextToken()){
                buf.append(t.image).append(" ");
            }
            result.setSubQuery(buf.toString());
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public AxionCommand SqlCreateServer() throws ParseException {
        CreateDatabaseLinkCommand result = new CreateDatabaseLinkCommand();
        Properties props = null;
    jj_consume_token(DATABASE);
    jj_consume_token(LINK);
    SqlIfNotExists(result);
    jj_consume_token(OPENPAREN);
    props = SqlReadProperties();
                result.setProperties(props);
    jj_consume_token(CLOSEPAREN);
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public AxionCommand SqlCreateIndex() throws ParseException {
        CreateIndexCommand result = new CreateIndexCommand();
        String str = null;
        String type = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case UNIQUE:
      jj_consume_token(UNIQUE);
                     result.setUnique(true);
      break;
    default:
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
    case START_QUOTED_IDENTIFIER:
      type = SqlIdentifier();
                                    result.setType(type);
      break;
    default:
      ;
    }
    jj_consume_token(INDEX);
    SqlIfNotExists(result);
    jj_consume_token(ON);
    str = SqlValueTerm();
            result.setTable(str);
            str = null;
    jj_consume_token(OPENPAREN);
    str = SqlIdentifier();
            result.addColumn(str);
             str = null;
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        break label_2;
      }
      jj_consume_token(COMMA);
      str = SqlIdentifier();
                result.addColumn(str);
                str = null;
    }
    jj_consume_token(CLOSEPAREN);
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public AxionCommand SqlCreateSequence() throws ParseException {
        CreateSequenceCommand result = new CreateSequenceCommand();
        Object[] tuple = new Object[5];
    jj_consume_token(SEQUENCE);
    SqlIfNotExists(result);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      jj_consume_token(AS);
      SqlExactNumericType(tuple);
                result.setDataType((String)tuple[1]);
      break;
    default:
      ;
    }
    SqlBasicSequenceOption(result);
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public void SqlBasicSequenceOption(CreateSequenceCommand result) throws ParseException {
        Token t = null;
        boolean ascending = true;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case START:
      jj_consume_token(START);
      jj_consume_token(WITH);
      t = jj_consume_token(INTEGER_LITERAL);
                result.setStartValue(t.image);
      break;
    default:
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INCREMENT:
      jj_consume_token(INCREMENT);
      jj_consume_token(BY);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MINUS:
        jj_consume_token(MINUS);
                      ascending = false;
        break;
      default:
        ;
      }
      t = jj_consume_token(INTEGER_LITERAL);
                String ib = t.image;
                if (ascending == false){
                    ib = "-" + t.image;
                }
                result.setIncrementBy(ib);
      break;
    default:
      ;
    }
    if (jj_2_3(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MAXVALUE:
        jj_consume_token(MAXVALUE);
        t = jj_consume_token(INTEGER_LITERAL);
                    result.setMaxValue(t.image);
        break;
      case NO:
        jj_consume_token(NO);
        jj_consume_token(MAXVALUE);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } else {
      ;
    }
    if (jj_2_4(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MINVALUE:
        jj_consume_token(MINVALUE);
        t = jj_consume_token(INTEGER_LITERAL);
                    result.setMinValue(t.image);
        break;
      case NO:
        jj_consume_token(NO);
        jj_consume_token(MINVALUE);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } else {
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CYCLE:
    case NO:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CYCLE:
        jj_consume_token(CYCLE);
                    result.setCycle(true);
        break;
      case NO:
        jj_consume_token(NO);
        jj_consume_token(CYCLE);
                    result.setCycle(false);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      ;
    }
  }

  final public AxionCommand SqlAlterSequence() throws ParseException {
        AlterSequenceCommand result = new AlterSequenceCommand();
        Token t = null;
        String name = null;
        boolean ascending = true;
    jj_consume_token(SEQUENCE);
    name = SqlIdentifier();
            result.setObjectName(name);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RESTART:
      jj_consume_token(RESTART);
      jj_consume_token(WITH);
      t = jj_consume_token(INTEGER_LITERAL);
                result.setStartValue(t.image);
      break;
    default:
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INCREMENT:
      jj_consume_token(INCREMENT);
      jj_consume_token(BY);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MINUS:
        jj_consume_token(MINUS);
                      ascending = false;
        break;
      default:
        ;
      }
      t = jj_consume_token(INTEGER_LITERAL);
                String ib = t.image;
                if (ascending == false){
                    ib = "-" + t.image;
                }
                result.setIncrementBy(ib);
      break;
    default:
      ;
    }
    if (jj_2_5(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MAXVALUE:
        jj_consume_token(MAXVALUE);
        t = jj_consume_token(INTEGER_LITERAL);
                    result.setMaxValue(t.image);
        break;
      case NO:
        jj_consume_token(NO);
        jj_consume_token(MAXVALUE);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } else {
      ;
    }
    if (jj_2_6(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MINVALUE:
        jj_consume_token(MINVALUE);
        t = jj_consume_token(INTEGER_LITERAL);
                    result.setMinValue(t.image);
        break;
      case NO:
        jj_consume_token(NO);
        jj_consume_token(MINVALUE);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } else {
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CYCLE:
    case NO:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CYCLE:
        jj_consume_token(CYCLE);
                    result.setCycle(true);
        break;
      case NO:
        jj_consume_token(NO);
        jj_consume_token(CYCLE);
                    result.setCycle(false);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      ;
    }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public void SqlIfNotExists(AxionCommand result) throws ParseException {
        CreateCommand cmd = (CreateCommand)result;
        String name = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
      jj_consume_token(IF);
      jj_consume_token(NOT);
      jj_consume_token(EXISTS);
                cmd.setIfNotExists(true);
      break;
    default:
      ;
    }
    name = SqlIdentifier();
            cmd.setObjectName(name);
  }

  final public Properties SqlReadProperties() throws ParseException {
        Properties props = new Properties();
        String key = null;
        Literal val = null;
    key = SqlIdentifier();
    jj_consume_token(EQUAL);
    val = SqlLiteral();
            props.setProperty(key, val.toString());
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
      case COMMA:
      case START_QUOTED_IDENTIFIER:
        ;
        break;
      default:
        break label_3;
      }
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          break label_4;
        }
        jj_consume_token(COMMA);
      }
      key = SqlIdentifier();
      jj_consume_token(EQUAL);
      val = SqlLiteral();
               props.setProperty(key, val.toString());
    }
            {if (true) return props;}
    throw new Error("Missing return statement in function");
  }

  final public void SqlColumnExpression(CreateTableCommand result) throws ParseException {
        Object[] tuple = null;
        Constraint constraint = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHECK:
    case CONSTRAINT:
    case FOREIGN:
    case NOT:
    case NULL:
    case PRIMARY:
    case REFERENCES:
    case UNIQUE:
      constraint = SqlTableConstraint();
                if (null != constraint) {
                    result.addChildCommand(new AddConstraintCommand(
                        result.getObjectName(),constraint));
                    constraint = null;
                }
      break;
    case ID:
    case START_QUOTED_IDENTIFIER:
      tuple = SqlColumnDef();
                  result.addColumn((String)tuple[0],(String)tuple[1],
                      (String)tuple[2], (String)tuple[3], tuple[4], (String)tuple[5]);
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CHECK:
        case CONSTRAINT:
        case FOREIGN:
        case NOT:
        case NULL:
        case PRIMARY:
        case REFERENCES:
        case UNIQUE:
          ;
          break;
        default:
          break label_5;
        }
        constraint = SqlColumnConstraint(result.getObjectName(),(String)tuple[0]);
                    if(null != constraint) {
                        result.addChildCommand(new AddConstraintCommand(
                                    result.getObjectName(),constraint));
                        constraint = null;
                    }
      }
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

    // ----------------------------------------------------------------------------
    // COMMANDS: DELETE
    // ----------------------------------------------------------------------------
  final public AxionCommand SqlDelete() throws ParseException {
        TableIdentifier table = null;
        Selectable where = null;
    jj_consume_token(DELETE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FROM:
      jj_consume_token(FROM);
      break;
    default:
      ;
    }
    table = SqlTableRef();
            protectSystemTable(table.getTableName());
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      where = SqlWhere();
      break;
    default:
      ;
    }
            {if (true) return new DeleteCommand(table,where);}
    throw new Error("Missing return statement in function");
  }

    // ----------------------------------------------------------------------------
    // COMMANDS: ALTER TABLE
    // ----------------------------------------------------------------------------
  final public AxionCommand SqlAlterCmd() throws ParseException {
        AxionCommand result = null;
    jj_consume_token(ALTER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TABLE:
      result = SqlAlterTable();
      break;
    case SEQUENCE:
      result = SqlAlterSequence();
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public AxionCommand SqlAlterTable() throws ParseException {
        AxionCommand result = null;
        String tablename = null;
    jj_consume_token(TABLE);
    tablename = SqlIdentifier();
            protectSystemTable(tablename);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DROP:
      result = SqlAlterTableDrop(tablename);
      break;
    case ADD:
      result = SqlAlterTableAdd(tablename);
      break;
    case ALTER:
      result = SqlAlterTableAlterColumn(tablename);
      break;
    case RENAME:
      result = SqlRenameTable(tablename);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public AxionCommand SqlRenameTable(String tablename) throws ParseException {
        String newName = null;
        boolean cascade = false;
    jj_consume_token(RENAME);
    jj_consume_token(TO);
    newName = SqlIdentifier();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CASCADE:
    case RESTRICT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CASCADE:
        jj_consume_token(CASCADE);
                      cascade = true;
        break;
      case RESTRICT:
        jj_consume_token(RESTRICT);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      ;
    }
            AlterTableCommand cmd = new AlterTableCommand(tablename, cascade);
            cmd.setRenameTo(newName);
            {if (true) return cmd;}
    throw new Error("Missing return statement in function");
  }

  final public AxionCommand SqlAlterTableAlterColumn(String tablename) throws ParseException {
        String oldColName = null;
        String newName = null;
        Selectable newDefault = null;
        Boolean dropdefault = null;
        boolean cascade = false;
    jj_consume_token(ALTER);
    jj_consume_token(COLUMN);
    oldColName = SqlIdentifier();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RENAME:
      jj_consume_token(RENAME);
      jj_consume_token(TO);
      newName = SqlIdentifier();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CASCADE:
      case RESTRICT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CASCADE:
          jj_consume_token(CASCADE);
                              cascade = true;
          break;
        case RESTRICT:
          jj_consume_token(RESTRICT);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        ;
      }
      break;
    case DROP:
      jj_consume_token(DROP);
      jj_consume_token(DEFAULT_);
                                    dropdefault = Boolean.TRUE;
      break;
    case SET:
      jj_consume_token(SET);
      jj_consume_token(DEFAULT_);
      newDefault = SqlSelectable();
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
            AlterTableCommand cmd = new AlterTableCommand(tablename, cascade);
            cmd.alterColumn(oldColName, newName, newDefault, dropdefault);
            {if (true) return cmd;}
    throw new Error("Missing return statement in function");
  }

  final public AxionCommand SqlDropColumn(String tablename) throws ParseException {
        String columnname = null;
        boolean cascade = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLUMN:
      jj_consume_token(COLUMN);
      break;
    default:
      ;
    }
    columnname = SqlIdentifier();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CASCADE:
    case RESTRICT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CASCADE:
        jj_consume_token(CASCADE);
                      cascade = true;
        break;
      case RESTRICT:
        jj_consume_token(RESTRICT);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      ;
    }
            AlterTableCommand cmd = new AlterTableCommand(tablename, cascade);
            cmd.dropColumn(columnname);
            {if (true) return cmd;}
    throw new Error("Missing return statement in function");
  }

  final public AxionCommand SqlAlterTableDrop(String tablename) throws ParseException {
        String constraintname = null;
        AxionCommand result = null;
        boolean cascade = false;
    jj_consume_token(DROP);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONSTRAINT:
    case PRIMARY:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONSTRAINT:
        jj_consume_token(CONSTRAINT);
        constraintname = SqlIdentifier();
        break;
      case PRIMARY:
        jj_consume_token(PRIMARY);
        jj_consume_token(KEY);
                        constraintname = "PRIMARYKEY";
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CASCADE:
      case RESTRICT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CASCADE:
          jj_consume_token(CASCADE);
                          cascade = true;
          break;
        case RESTRICT:
          jj_consume_token(RESTRICT);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        ;
      }
                result = new DropConstraintCommand(tablename, constraintname, cascade);
      break;
    case COLUMN:
    case ID:
    case START_QUOTED_IDENTIFIER:
      result = SqlDropColumn(tablename);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public AxionCommand SqlAlterTableAdd(String tablename) throws ParseException {
        Constraint constraint = null;
        AlterTableCommand altCmd = null;
        Object[] tuple = null;
    jj_consume_token(ADD);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHECK:
    case CONSTRAINT:
    case FOREIGN:
    case NOT:
    case NULL:
    case PRIMARY:
    case REFERENCES:
    case UNIQUE:
      constraint = SqlTableConstraint();
                if(null == constraint) {
                    {if (true) return null;}
                } else {
                    {if (true) return new AddConstraintCommand(tablename,constraint);}
                }
      break;
    case COLUMN:
    case ID:
    case START_QUOTED_IDENTIFIER:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COLUMN:
        jj_consume_token(COLUMN);
        break;
      default:
        ;
      }
      tuple = SqlColumnDef();
                    altCmd = new AlterTableCommand(tablename, false);
                    altCmd.addColumn((String)tuple[0],(String)tuple[1],
                          (String)tuple[2], (String)tuple[3], (Selectable)tuple[4],
                          (String)tuple[5]);
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CHECK:
        case CONSTRAINT:
        case FOREIGN:
        case NOT:
        case NULL:
        case PRIMARY:
        case REFERENCES:
        case UNIQUE:
          ;
          break;
        default:
          break label_6;
        }
        constraint = SqlColumnConstraint(tablename,(String)tuple[0]);
                        if(null != constraint) {
                            altCmd.addChildCommand(new AddConstraintCommand(tablename,constraint));
                            constraint = null;
                        }
      }
                {if (true) return altCmd;}
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

    // ----------------------------------------------------------------------------
    // COMMANDS: DROP
    // ----------------------------------------------------------------------------
  final public AxionCommand SqlDrop() throws ParseException {
        AxionCommand result = null;
    jj_consume_token(DROP);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TABLE:
      result = SqlDropTable();
      break;
    case VIEW:
      result = SqlDropView();
      break;
    case INDEX:
      result = SqlDropIndex();
      break;
    case SEQUENCE:
      result = SqlDropSequence();
      break;
    case DATABASE:
      result = SqlDropServer();
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public AxionCommand SqlDropTable() throws ParseException {
        DropTableCommand result = null;
        String tableName = null;
        boolean exists = false;
        boolean cascade = false;
    jj_consume_token(TABLE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
      jj_consume_token(IF);
      jj_consume_token(EXISTS);
                                exists = true;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CASCADE:
      case RESTRICT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CASCADE:
          jj_consume_token(CASCADE);
                             cascade = true;
          break;
        case RESTRICT:
          jj_consume_token(RESTRICT);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        ;
      }
      break;
    default:
      ;
    }
    tableName = SqlIdentifier();
                protectSystemTable(tableName);
                result = new DropTableCommand(tableName, exists, cascade);
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public AxionCommand SqlDropView() throws ParseException {
        DropViewCommand result = null;
        String tableName = null;
        boolean exists = false;
        boolean cascade = false;
    jj_consume_token(VIEW);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
      jj_consume_token(IF);
      jj_consume_token(EXISTS);
                                exists = true;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CASCADE:
      case RESTRICT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CASCADE:
          jj_consume_token(CASCADE);
                             cascade = true;
          break;
        case RESTRICT:
          jj_consume_token(RESTRICT);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        ;
      }
      break;
    default:
      ;
    }
    tableName = SqlIdentifier();
                   result = new DropViewCommand(tableName, exists, cascade);
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public AxionCommand SqlDropServer() throws ParseException {
        DropDatabaseLinkCommand result = null;
        String dblinkName = null;
        boolean exists = false;
        boolean cascade = false;
    jj_consume_token(DATABASE);
    jj_consume_token(LINK);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
      jj_consume_token(IF);
      jj_consume_token(EXISTS);
                                exists = true;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CASCADE:
      case RESTRICT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CASCADE:
          jj_consume_token(CASCADE);
                             cascade = true;
          break;
        case RESTRICT:
          jj_consume_token(RESTRICT);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        ;
      }
      break;
    default:
      ;
    }
    dblinkName = SqlIdentifier();
                result = new DropDatabaseLinkCommand(dblinkName, exists, cascade);
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public AxionCommand SqlDropIndex() throws ParseException {
        DropIndexCommand result = null;
        String name = null;
        boolean exists = false;
    jj_consume_token(INDEX);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
      jj_consume_token(IF);
      jj_consume_token(EXISTS);
                              exists = true;
      break;
    default:
      ;
    }
    name = SqlIdentifier();
                result = new DropIndexCommand(name, exists);
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public AxionCommand SqlDropSequence() throws ParseException {
        DropSequenceCommand result = null;
        String sequenceName = null;
        boolean exists = false;
    jj_consume_token(SEQUENCE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IF:
      jj_consume_token(IF);
      jj_consume_token(EXISTS);
                              exists = true;
      break;
    default:
      ;
    }
    sequenceName = SqlIdentifier();
                   result = new DropSequenceCommand(sequenceName, exists);
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

    // ----------------------------------------------------------------------------
    // COMMANDS: INSERT
    // ----------------------------------------------------------------------------
  final public AxionCommand SqlInsert() throws ParseException {
        InsertCommand insertCommand = null;
        Token t = null;
    jj_consume_token(INSERT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ALL:
    case FIRST:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALL:
        t = jj_consume_token(ALL);
        break;
      case FIRST:
        t = jj_consume_token(FIRST);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      insertCommand = SqlMultiTableInsert();
                    if(t.image.equalsIgnoreCase("first")) {
                        insertCommand.setMultiTableEvaluationMode(InsertCommand.WHEN_FIRST);
                    }
                    {if (true) return insertCommand;}
      break;
    case INTO:
      jj_consume_token(INTO);
      insertCommand = SqlSingleTableInsert();
                    {if (true) return insertCommand;}
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public InsertCommand SqlMultiTableInsert() throws ParseException {
        InsertCommand insertCommand = new InsertCommand();
        AxionCommand subselect = null;
        String aliasName;
    label_7:
    while (true) {
      SqlInsertIntoClause(insertCommand);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTO:
      case WHEN:
        ;
        break;
      default:
        break label_7;
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      SqlInsertElseClause(insertCommand);
      break;
    default:
      ;
    }
    jj_consume_token(OPENPAREN);
    subselect = SqlSubSelect();
    jj_consume_token(CLOSEPAREN);
                  insertCommand.setSubSelect((SubSelectCommand)subselect);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
    case ID:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AS:
        jj_consume_token(AS);
        break;
      default:
        ;
      }
      aliasName = SqlUnquotedId();
                    ((SubSelectCommand)subselect).setAlias(aliasName);
      break;
    default:
      ;
    }
            {if (true) return insertCommand;}
    throw new Error("Missing return statement in function");
  }

  final public InsertCommand SqlSingleTableInsert() throws ParseException {
        TableIdentifier table = null;
        List columns = null;
        List values = null;
        AxionCommand subselect = null;
        InsertCommand insertCommand = null;
    table = SqlTableRef();
            protectSystemTable(table.getTableName());
    if (jj_2_7(2)) {
      jj_consume_token(OPENPAREN);
      columns = SqlSelectCols();
      jj_consume_token(CLOSEPAREN);
    } else {
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VALUES:
      values = insertValues();
                  insertCommand = new InsertCommand(table, columns, values);
      break;
    case DEFAULT_:
      jj_consume_token(DEFAULT_);
      jj_consume_token(VALUES);
                insertCommand = new InsertCommand(table, columns, true);
      break;
    default:
      subselect = SqlSubSelect();
                  insertCommand = new InsertCommand(table, columns, subselect);
    }
            {if (true) return insertCommand;}
    throw new Error("Missing return statement in function");
  }

  final public DMLWhenClause SqlDMLWhenClause() throws ParseException {
        Selectable condition = null;
    jj_consume_token(WHEN);
    condition = SqlWhereOr();
    jj_consume_token(THEN);
            {if (true) return new DMLWhenClause(condition);}
    throw new Error("Missing return statement in function");
  }

  final public void SqlInsertIntoClause(InsertCommand insertCommand) throws ParseException {
        DMLWhenClause when = null;
        TableIdentifier tid = null;
        List cols = null;
        List vals = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHEN:
      when = SqlDMLWhenClause();
      break;
    default:
      ;
    }
    jj_consume_token(INTO);
    tid = SqlTableRef();
            protectSystemTable(tid.getTableName());
    if (jj_2_8(2)) {
      jj_consume_token(OPENPAREN);
      cols = SqlSelectCols();
      jj_consume_token(CLOSEPAREN);
    } else {
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VALUES:
      vals = insertValues();
      break;
    default:
      ;
    }
            insertCommand.addInsertIntoClause(when, tid, cols, vals);
  }

  final public void SqlInsertElseClause(InsertCommand insertCommand) throws ParseException {
        TableIdentifier tid = null;
        List cols = null;
        List vals = null;
    jj_consume_token(ELSE);
            if(insertCommand.isInsertIntoListEmpty()){
                {if (true) throw new ParseException("Can't use ELSE without a WHEN...");}
            }
    jj_consume_token(INTO);
    tid = SqlTableRef();
            protectSystemTable(tid.getTableName());
    if (jj_2_9(2)) {
      jj_consume_token(OPENPAREN);
      cols = SqlSelectCols();
      jj_consume_token(CLOSEPAREN);
    } else {
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VALUES:
      vals = insertValues();
      break;
    default:
      ;
    }
            insertCommand.setElseClause(tid, cols, vals);
  }

  final public List insertValues() throws ParseException {
        List values  = null;
    jj_consume_token(VALUES);
    jj_consume_token(OPENPAREN);
    values = SqlSelectList();
    jj_consume_token(CLOSEPAREN);
            {if (true) return values;}
    throw new Error("Missing return statement in function");
  }

    // ----------------------------------------------------------------------------
    // COMMANDS: SELECT
    // ----------------------------------------------------------------------------
  final public AxionCommand SqlSelect() throws ParseException {
        AxionQueryContext context = null;
    context = SqlSelectContext();
            {if (true) return new SelectCommand(context);}
    throw new Error("Missing return statement in function");
  }

  final public AxionQueryContext SqlSelectContext() throws ParseException {
        AxionQueryContext result = new AxionQueryContext();
        List colList = null;
        Selectable where = null;
        Selectable having = null;
        List order = null;
        List group = null;
        Literal limit = null;
        Literal offset = null;
        FromNode from = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXPLAIN:
      jj_consume_token(EXPLAIN);
                     result.setExplain(true);
      break;
    default:
      ;
    }
    jj_consume_token(SELECT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ALL:
    case DISTINCT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALL:
        jj_consume_token(ALL);
                result.setDistinct(false);
        break;
      case DISTINCT:
        jj_consume_token(DISTINCT);
                result.setDistinct(true);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      ;
    }
    // can gather all cols here and add to builder as list
            // or one at a time farther down the parse tree
            // problem is, farther down the parse tree, might not
            // know we're getting column identifiers, might need to
            // pass column identifiers back to production where
            // context is obvious
            colList = SqlSelectCols();
            result.setSelect(colList);
    if (jj_2_10(2)) {
      jj_consume_token(FROM);
      from = SqlFrom();
                result.setFrom(from);
    } else {
      ;
    }
    if (jj_2_11(2)) {
      where = SqlWhere();
    } else {
      ;
    }
    if (jj_2_13(2)) {
      group = SqlGroupBy();
      if (jj_2_12(2)) {
        jj_consume_token(HAVING);
        having = SqlWhereOr();
      } else {
        ;
      }
    } else {
      ;
    }
    if (jj_2_14(2)) {
      order = SqlOrderBy();
    } else {
      ;
    }
    if (jj_2_15(2)) {
      limit = SqlSelectLimit();
    } else {
      ;
    }
    if (jj_2_16(2)) {
      offset = SqlSelectOffset();
    } else {
      ;
    }
            result.setWhere(where);
            result.setGroupBy(group);
            result.setHaving(having);
            result.setOrderBy(order);
            result.setLimit(limit);
            result.setOffset(offset);
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public List SqlSelectCols() throws ParseException {
        List list = new ArrayList();
    if (jj_2_18(2)) {
      if (jj_2_17(2)) {
        jj_consume_token(ASTERISK);
                             list.add(new ColumnIdentifier("*"));
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CAST:
        case CASE:
        case CURRENT_TIMESTAMP:
        case CURRENT_DATE:
        case CURRENT_TIME:
        case DAY:
        case EXISTS:
        case EXTRACT:
        case FALSE:
        case HOUR:
        case MINUTE:
        case MILLISECOND:
        case MONTH:
        case NEXT:
        case NOT:
        case NULL:
        case POSITION:
        case QUARTER:
        case SECOND:
        case SUBSTRING:
        case SYSDATE:
        case TRIM:
        case TRUE:
        case WEEK:
        case YEAR:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case STRING_LITERAL:
        case ID:
        case OPENPAREN:
        case ASTERISK:
        case MINUS:
        case QUESTIONMARK:
        case START_QUOTED_IDENTIFIER:
          list = SqlSelectList();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } else {
      ;
    }
            {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

  final public ColumnIdentifier SqlNextValueFor() throws ParseException {
        String name = null;
    jj_consume_token(NEXT);
    jj_consume_token(VALUE);
    jj_consume_token(FOR);
    name = SqlIdentifier();
            {if (true) return new ColumnIdentifier(name + ".NEXTVAL");}
    throw new Error("Missing return statement in function");
  }

  final public Literal SqlSelectLimit() throws ParseException {
        Literal limit = null;
    jj_consume_token(LIMIT);
    limit = SqlNumericLiteralOrBindVar();
            {if (true) return limit;}
    throw new Error("Missing return statement in function");
  }

  final public Literal SqlSelectOffset() throws ParseException {
        Literal offset = null;
    jj_consume_token(OFFSET);
    offset = SqlNumericLiteralOrBindVar();
            {if (true) return offset;}
    throw new Error("Missing return statement in function");
  }

  final public Literal SqlNumericLiteralOrBindVar() throws ParseException {
        Literal value = null;
    value = SqlLiteralOrBindVar();
            try {
                if(!(value instanceof BindVariable || value.evaluate(null) instanceof Number)) {
                       {if (true) throw new ParseException("Expected numeric literal or bind variable.");}
                }
            } catch(AxionException e) {
                {if (true) throw new ParseException("AxionException " + e.toString()
                        + " while parsing OFFSET. Shouldn't happen.");}
            }
            {if (true) return value;}
    throw new Error("Missing return statement in function");
  }

  final public Literal SqlLiteralOrBindVar() throws ParseException {
        Literal value = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FALSE:
    case NULL:
    case TRUE:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case ASTERISK:
    case MINUS:
      value = SqlLiteral();
      break;
    case QUESTIONMARK:
      value = SqlBindVar();
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
            {if (true) return value;}
    throw new Error("Missing return statement in function");
  }

    // ----------------------------------------------------------------------------
    // COMMANDS: UPDATE
    // ----------------------------------------------------------------------------
  final public AxionCommand SqlUpdate() throws ParseException {
        TableIdentifier table = null;
        List colvalpairs = new ArrayList();
        Selectable where = null;
        Selectable[] curpair = null;
        UpdateCommand cmd = new UpdateCommand();
        FromNode from = null;

        // implicit inner join between target table and From Caluse
        FromNode fromInner = null;
    jj_consume_token(UPDATE);
    table = SqlTableRef();
                protectSystemTable(table.getTableName());
                cmd.setTable(table);
    jj_consume_token(SET);
    curpair = SqlUpdateAssignment();
                colvalpairs.add(curpair);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        break label_8;
      }
      jj_consume_token(COMMA);
      curpair = SqlUpdateAssignment();
                    colvalpairs.add(curpair);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FROM:
      jj_consume_token(FROM);
      from = SqlFrom();
                AxionQueryContext context = new AxionQueryContext();
                fromInner = new FromNode();
                fromInner.setLeft(table);
                fromInner.setRight(from);
                fromInner.setType(FromNode.TYPE_INNER);
                context.setFrom(fromInner);
                cmd.setQueryContext(context);
      break;
    default:
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      where = SqlWhere();
      break;
    default:
      ;
    }
            Iterator iter = colvalpairs.iterator();
            while(iter.hasNext()) {
                Selectable[] pair = (Selectable[])(iter.next());
                cmd.addColumn((ColumnIdentifier)pair[0]);
                cmd.addValue(pair[1]);
            }

            // Found FromNode in update
            if(fromInner != null) {
                // Move where condition to implicit join level otherwise we might end up getting a 
                // FilteringRowIterator where as we expect a JoinedRowIterator in UpdateCommand
                if(where != null) {
                    fromInner.setCondition(where);
                }
            } else { // Regular update syntax
                cmd.setWhere(where);
            }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXCEPTION:
      SqlUpdateExceptionWhenClause(cmd);
      break;
    default:
      ;
    }
            {if (true) return cmd;}
    throw new Error("Missing return statement in function");
  }

  final public void SqlUpdateExceptionWhenClause(UpdateCommand cmd) throws ParseException {
        DMLWhenClause when = null;
        TableIdentifier tid = null;
        List cols = null;
        List vals = null;
    jj_consume_token(EXCEPTION);
    when = SqlDMLWhenClause();
    jj_consume_token(INSERT);
    jj_consume_token(INTO);
    tid = SqlTableRef();
            protectSystemTable(tid.getTableName());
    if (jj_2_19(2)) {
      jj_consume_token(OPENPAREN);
      cols = SqlSelectCols();
      jj_consume_token(CLOSEPAREN);
    } else {
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VALUES:
      vals = insertValues();
      break;
    default:
      ;
    }
            cmd.setExceptionWhenClause(when, tid, cols, vals);
  }

  final public Selectable[] SqlUpdateAssignment() throws ParseException {
        Selectable[] pair = new Selectable[2];
    pair[0] = SqlColumnRef();
    jj_consume_token(EQUAL);
    pair[1] = SqlSumExprSelectable();
            {if (true) return pair;}
    throw new Error("Missing return statement in function");
  }

    // ----------------------------------------------------------------------------
    // COMMANDS: UPSERT
    // ----------------------------------------------------------------------------
  final public AxionCommand SqlUpsert() throws ParseException {
        UpsertCommand upsertCmd = new UpsertCommand();
        TableIdentifier target_table = null;
        TableIdentifier source_table = null;

        // create select command
        AxionQueryContext selectCmdCtx = new AxionQueryContext();
        FromNode from = new FromNode();
        Selectable condition = null;

        // column, value List for update
        Selectable[] curpair = null;
        List columnValuePairsForUpdate = new ArrayList();

        // column, value List for insert
        List columns = null;
        List values = null;
        AxionCommand subselect = null;
        String aliasName;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case UPSERT:
      jj_consume_token(UPSERT);
      break;
    case MERGE:
      jj_consume_token(MERGE);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
            // Initialize the Select Query to create LOJ
            List list = new ArrayList();
            list.add(new ColumnIdentifier("*"));
            selectCmdCtx.setSelect(list);
            selectCmdCtx.setFrom(from);
            upsertCmd.setSelectCommand(new SubSelectCommand(selectCmdCtx));
    jj_consume_token(INTO);
    target_table = SqlTableRef();
            protectSystemTable(target_table.getTableName());
            from.setRight(target_table);
            upsertCmd.setTargetTable(target_table);
    jj_consume_token(USING);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
    case START_QUOTED_IDENTIFIER:
      source_table = SqlTableRef();
                from.setLeft(source_table);
                upsertCmd.setSourceTable(source_table);
      break;
    case OPENPAREN:
      jj_consume_token(OPENPAREN);
      subselect = SqlSubSelect();
      jj_consume_token(CLOSEPAREN);
                    upsertCmd.setUsingSubSelectCommand((SubSelectCommand)subselect);
                    from.setLeft(subselect);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AS:
        jj_consume_token(AS);
        break;
      default:
        ;
      }
      aliasName = SqlUnquotedId();
                    upsertCmd.setUsingSubSelectAlias(aliasName);
                    ((SubSelectCommand)subselect).setAlias(aliasName);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(ON);
    condition = SqlWhereOr();
            from.setCondition(condition);
            from.setType(FromNode.TYPE_LEFT);
            upsertCmd.setCondition(condition);
    jj_consume_token(WHEN);
    jj_consume_token(MATCHED);
    jj_consume_token(THEN);
    jj_consume_token(UPDATE);
    jj_consume_token(SET);
    curpair = SqlUpdateAssignment();
                columnValuePairsForUpdate.add(curpair);
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        break label_9;
      }
      jj_consume_token(COMMA);
      curpair = SqlUpdateAssignment();
                    columnValuePairsForUpdate.add(curpair);
    }
            Iterator iter = columnValuePairsForUpdate.iterator();
            while(iter.hasNext()) {
                Selectable[] pair = (Selectable[])(iter.next());
                upsertCmd.addUpdateColumn((ColumnIdentifier)pair[0]);
                upsertCmd.addUpdateValue(pair[1]);
            }
    jj_consume_token(WHEN);
    jj_consume_token(NOT);
    jj_consume_token(MATCHED);
    jj_consume_token(THEN);
    jj_consume_token(INSERT);
    jj_consume_token(OPENPAREN);
    columns = SqlSelectCols();
    jj_consume_token(CLOSEPAREN);
    values = insertValues();
                  upsertCmd.setColumnsForInsert(columns);
                  upsertCmd.setValuesForInsert(values);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXCEPTION:
      SqlUpsertExceptionWhenClause(upsertCmd);
      break;
    default:
      ;
    }
            {if (true) return upsertCmd;}
    throw new Error("Missing return statement in function");
  }

  final public void SqlUpsertExceptionWhenClause(UpsertCommand cmd) throws ParseException {
        DMLWhenClause when = null;
        TableIdentifier tid = null;
        List cols = null;
        List vals = null;
    jj_consume_token(EXCEPTION);
    when = SqlDMLWhenClause();
    jj_consume_token(INSERT);
    jj_consume_token(INTO);
    tid = SqlTableRef();
            protectSystemTable(tid.getTableName());
    if (jj_2_20(2)) {
      jj_consume_token(OPENPAREN);
      cols = SqlSelectCols();
      jj_consume_token(CLOSEPAREN);
    } else {
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VALUES:
      vals = insertValues();
      break;
    default:
      ;
    }
            cmd.setExceptionWhenClause(when, tid, cols, vals);
  }

    // ----------------------------------------------------------------------------
    // CONSTRAINTS
    // ----------------------------------------------------------------------------
  final public Constraint SqlTableConstraint() throws ParseException {
        Constraint constraint = null;
        String name = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONSTRAINT:
      jj_consume_token(CONSTRAINT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
      case START_QUOTED_IDENTIFIER:
        name = SqlIdentifier();
        break;
      default:
        ;
      }
      break;
    default:
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
    case NULL:
    case PRIMARY:
    case UNIQUE:
      constraint = SqlSelectableBasedConstraintType(name);
      SqlSelectableBasedConstraintArgs((SelectableBasedConstraint)constraint);
      break;
    case CHECK:
      constraint = SqlCheckConstraintType(name);
      break;
    case FOREIGN:
    case REFERENCES:
      constraint = SqlForeignKeyConstraintType(name);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (jj_2_21(2)) {
      SqlDeferrable(constraint);
    } else {
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INITIALLY:
      SqlInitiallyDeferredOrImmediate(constraint);
      break;
    default:
      ;
    }
            {if (true) return constraint;}
    throw new Error("Missing return statement in function");
  }

  final public Constraint SqlColumnConstraint(String tablename, String columnname) throws ParseException {
        Constraint constraint = null;
        String name = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONSTRAINT:
      jj_consume_token(CONSTRAINT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
      case START_QUOTED_IDENTIFIER:
        name = SqlIdentifier();
        break;
      default:
        ;
      }
      break;
    default:
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
    case NULL:
    case PRIMARY:
    case UNIQUE:
      constraint = SqlSelectableBasedConstraintType(name);
                    ((SelectableBasedConstraint)constraint).addSelectable(
                        new ColumnIdentifier(new TableIdentifier(tablename),columnname));
      break;
    case CHECK:
      constraint = SqlCheckConstraintType(name);
      break;
    case FOREIGN:
    case REFERENCES:
      constraint = SqlForeignKeyConstraintType(name);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (jj_2_22(2)) {
      SqlDeferrable(constraint);
    } else {
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INITIALLY:
      SqlInitiallyDeferredOrImmediate(constraint);
      break;
    default:
      ;
    }
            {if (true) return constraint;}
    throw new Error("Missing return statement in function");
  }

  final public SelectableBasedConstraint SqlSelectableBasedConstraintType(String constraintname) throws ParseException {
        SelectableBasedConstraint constraint = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIMARY:
      jj_consume_token(PRIMARY);
      jj_consume_token(KEY);
                    constraint = new PrimaryKeyConstraint(constraintname);
      break;
    case NULL:
      jj_consume_token(NULL);
                    constraint = new NullConstraint(constraintname);
      break;
    case NOT:
      jj_consume_token(NOT);
      jj_consume_token(NULL);
                    constraint = new NotNullConstraint(constraintname);
      break;
    case UNIQUE:
      jj_consume_token(UNIQUE);
                    constraint = new UniqueConstraint(constraintname);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
            {if (true) return constraint;}
    throw new Error("Missing return statement in function");
  }

  final public CheckConstraint SqlCheckConstraintType(String constraintname) throws ParseException {
        CheckConstraint constraint = null;
        Selectable where = null;
    jj_consume_token(CHECK);
                constraint = new CheckConstraint(constraintname);
    jj_consume_token(OPENPAREN);
    where = SqlWhereOr();
    jj_consume_token(CLOSEPAREN);
                constraint.setCondition(where);
            {if (true) return constraint;}
    throw new Error("Missing return statement in function");
  }

  final public ForeignKeyConstraint SqlForeignKeyConstraintType(String constraintname) throws ParseException {
        ForeignKeyConstraint constraint = null;
        String tablename = null;
        List colList = new ArrayList();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FOREIGN:
      jj_consume_token(FOREIGN);
      jj_consume_token(KEY);
      jj_consume_token(OPENPAREN);
      colList = SqlSelectList();
      jj_consume_token(CLOSEPAREN);
      break;
    default:
      ;
    }
    jj_consume_token(REFERENCES);
    tablename = SqlIdentifier();
                constraint = new ForeignKeyConstraint(constraintname);
                constraint.addColumns(colList);
                constraint.setParentTableName(tablename);
    if (jj_2_23(2)) {
      jj_consume_token(OPENPAREN);
      colList = SqlSelectList();
      jj_consume_token(CLOSEPAREN);
                    constraint.addForeignColumns(colList);
    } else {
      ;
    }
    if (jj_2_24(2)) {
      jj_consume_token(ON);
      SqlForeignKeyConstraintTriger(constraint);
    } else {
      ;
    }
    if (jj_2_25(2)) {
      jj_consume_token(ON);
      SqlForeignKeyConstraintTriger(constraint);
    } else {
      ;
    }
            {if (true) return constraint;}
    throw new Error("Missing return statement in function");
  }

  final public void SqlForeignKeyConstraintTriger(ForeignKeyConstraint constraint) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DELETE:
      jj_consume_token(DELETE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CASCADE:
        jj_consume_token(CASCADE);
                    constraint.setOnDeleteActionType(ForeignKeyConstraint.CASCADE);
        break;
      case SET:
        jj_consume_token(SET);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NULL:
          jj_consume_token(NULL);
                        constraint.setOnDeleteActionType(ForeignKeyConstraint.SETNULL);
          break;
        case DEFAULT_:
          jj_consume_token(DEFAULT_);
                        constraint.setOnDeleteActionType(ForeignKeyConstraint.SETDEFAULT);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case NO:
      case RESTRICT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case RESTRICT:
          jj_consume_token(RESTRICT);
          break;
        case NO:
          jj_consume_token(NO);
          jj_consume_token(ACTION);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
                    constraint.setOnDeleteActionType(ForeignKeyConstraint.RESTRICT);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    case UPDATE:
      jj_consume_token(UPDATE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CASCADE:
        jj_consume_token(CASCADE);
                    constraint.setOnUpdateActionType(ForeignKeyConstraint.CASCADE);
        break;
      case SET:
        jj_consume_token(SET);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NULL:
          jj_consume_token(NULL);
                        constraint.setOnUpdateActionType(ForeignKeyConstraint.SETNULL);
          break;
        case DEFAULT_:
          jj_consume_token(DEFAULT_);
                        constraint.setOnUpdateActionType(ForeignKeyConstraint.SETDEFAULT);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case NO:
      case RESTRICT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case RESTRICT:
          jj_consume_token(RESTRICT);
          break;
        case NO:
          jj_consume_token(NO);
          jj_consume_token(ACTION);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
                    constraint.setOnUpdateActionType(ForeignKeyConstraint.RESTRICT);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void SqlSelectableBasedConstraintArgs(SelectableBasedConstraint constraint) throws ParseException {
        Selectable selectable = null;
    jj_consume_token(OPENPAREN);
    selectable = SqlSelectableElements();
            constraint.addSelectable(selectable);
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        break label_10;
      }
      jj_consume_token(COMMA);
      selectable = SqlSelectableElements();
                constraint.addSelectable(selectable);
    }
    jj_consume_token(CLOSEPAREN);
  }

  final public void SqlDeferrable(Constraint constraint) throws ParseException {
        boolean deferrable = true;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);
                deferrable = false;
      break;
    default:
      ;
    }
    jj_consume_token(DEFERRABLE);
            constraint.setDeferrable(deferrable);
  }

  final public void SqlInitiallyDeferredOrImmediate(Constraint constraint) throws ParseException {
    jj_consume_token(INITIALLY);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DEFERRED:
      jj_consume_token(DEFERRED);
                    try {
                        constraint.setDeferred(true);
                    } catch(AxionException e) {
                        {if (true) throw new ParseException("Constraint not deferrable " +
                                "(use DEFERRABLE before INITIALLY DEFERRED)");}
                    }
      break;
    case IMMEDIATE:
      jj_consume_token(IMMEDIATE);
                    try {
                        constraint.setDeferred(false);
                    } catch(AxionException e) {
                        {if (true) throw new ParseException("Constraint not deferrable (use DEFERRABLE)");}
                    }
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

    // ----------------------------------------------------------------------------
    // GENERIC STUFF (IDENTIFIERS, LITERALS, ETC.)
    // ----------------------------------------------------------------------------
  final public String SqlIdentifier() throws ParseException {
        String id = null;
    id = SqlQuotedId();
            {if (true) return id;}
    throw new Error("Missing return statement in function");
  }

  final public String SqlQuotedId() throws ParseException {
        Token t = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
      t = jj_consume_token(ID);
                {if (true) return t.image.toUpperCase();}
      break;
    case START_QUOTED_IDENTIFIER:
      jj_consume_token(START_QUOTED_IDENTIFIER);
      t = jj_consume_token(QUOTED_IDENTIFIER);
      jj_consume_token(END_QUOTED_IDENTIFIER);
                {if (true) return t.image.toUpperCase();}
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String SqlUnquotedId() throws ParseException {
        Token t = null;
    t = jj_consume_token(ID);
            {if (true) return t.image.toUpperCase();}
    throw new Error("Missing return statement in function");
  }

  final public BindVariable SqlBindVar() throws ParseException {
    jj_consume_token(QUESTIONMARK);
            {if (true) return new BindVariable();}
    throw new Error("Missing return statement in function");
  }

  final public Object[] SqlColumnDef() throws ParseException {
        Object[] tuple = new Object[6];
        CreateSequenceCommand seqCmd = new CreateSequenceCommand();
    tuple[0] = SqlValueTerm();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
    case BIGINT:
    case NUMERIC:
    case NUMBER:
    case DECIMAL:
    case DEC:
    case INTEGER:
    case SMALLINT:
    case SHORT:
      SqlExactNumericType(tuple);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DEFAULT_:
      case GENERATED:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DEFAULT_:
          jj_consume_token(DEFAULT_);
          tuple[4] = SqlSelectable();
          break;
        case GENERATED:
          jj_consume_token(GENERATED);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ALWAYS:
            jj_consume_token(ALWAYS);
                                        seqCmd.setIdentityType(Column.GENERATED_ALWAYS);
            break;
          case BY:
            jj_consume_token(BY);
            jj_consume_token(DEFAULT_);
                                                 seqCmd.setIdentityType(Column.GENERATED_BY_DEFAULT);
            break;
          default:
            jj_consume_token(-1);
            throw new ParseException();
          }
          jj_consume_token(AS);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTITY:
            jj_consume_token(IDENTITY);
            SqlBasicSequenceOption(seqCmd);
                                    seqCmd.setObjectName((String)tuple[0]);
                                    tuple[4] = seqCmd;
            break;
          case OPENPAREN:
            jj_consume_token(OPENPAREN);
            tuple[4] = SqlSelectable();
            jj_consume_token(CLOSEPAREN);
                                    tuple[5] = Column.GENERATED_ALWAYS;
            break;
          default:
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        ;
      }
      break;
    case BIT:
    case BYTE:
    case REAL:
    case CLOB:
    case BLOB:
    case CHAR:
    case CHARACTER:
    case DATE:
    case TIME:
    case FLOAT:
    case LONG:
    case RAW:
    case STRING:
    case BINARY:
    case BOOLEAN:
    case VARCHAR:
    case VARCHAR2:
    case LONGVARCHAR:
    case TEXT:
    case VARBINARY:
    case LONGVARBINARY:
    case IMAGE:
    case TIMESTAMP:
    case JAVA_OBJECT:
    case DOUBLE:
    case ID:
      if (jj_2_26(2)) {
        SqlCharStringType(tuple);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BYTE:
        case BLOB:
        case LONG:
        case RAW:
        case BINARY:
        case VARBINARY:
        case LONGVARBINARY:
        case IMAGE:
          SqlBinaryStringType(tuple);
          break;
        case REAL:
        case FLOAT:
        case DOUBLE:
          SqlApproximateNumericType(tuple);
          break;
        case BIT:
        case BOOLEAN:
          SqlBooleanType(tuple);
          break;
        case DATE:
        case TIME:
        case TIMESTAMP:
          SqlDataTimeType(tuple);
          break;
        case JAVA_OBJECT:
          SqlJavaObjectType(tuple);
          break;
        case ID:
          SqlUserDefinedType(tuple);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DEFAULT_:
      case GENERATED:
        SqlGCAndDefaultClause(tuple);
        break;
      default:
        ;
      }
      break;
    case DEFAULT_:
    case GENERATED:
      SqlGCAndDefaultClause(tuple);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
            {if (true) return tuple;}
    throw new Error("Missing return statement in function");
  }

  final public void SqlGCAndDefaultClause(Object[] tuple) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DEFAULT_:
      jj_consume_token(DEFAULT_);
      tuple[4] = SqlSelectable();
      break;
    case GENERATED:
      jj_consume_token(GENERATED);
      jj_consume_token(ALWAYS);
      jj_consume_token(AS);
                tuple[5] = Column.GENERATED_ALWAYS;
      jj_consume_token(OPENPAREN);
      tuple[4] = SqlSelectable();
      jj_consume_token(CLOSEPAREN);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void SqlCharStringType(Object[] tuple) throws ParseException {
    if (jj_2_28(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CHAR:
        jj_consume_token(CHAR);
        break;
      case CHARACTER:
        jj_consume_token(CHARACTER);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
                tuple[1] = "CHAR";
                tuple[2] = "1";
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPENPAREN:
        SqlCharLength(tuple);
        break;
      default:
        ;
      }
    } else if (jj_2_29(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CHAR:
        jj_consume_token(CHAR);
        jj_consume_token(VARYING);
        break;
      case CHARACTER:
        jj_consume_token(CHARACTER);
        jj_consume_token(VARYING);
        break;
      case VARCHAR:
        jj_consume_token(VARCHAR);
        break;
      case VARCHAR2:
        jj_consume_token(VARCHAR2);
        break;
      case STRING:
        jj_consume_token(STRING);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
                tuple[1] = "VARCHAR";
                tuple[2] = "1";
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPENPAREN:
        SqlCharLength(tuple);
        break;
      default:
        ;
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LONG:
      case LONGVARCHAR:
      case TEXT:
        if (jj_2_27(2)) {
          jj_consume_token(LONG);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LONG:
            jj_consume_token(LONG);
            jj_consume_token(VARCHAR);
            break;
          case LONGVARCHAR:
            jj_consume_token(LONGVARCHAR);
            break;
          case TEXT:
            jj_consume_token(TEXT);
            break;
          default:
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
                tuple[1] = "VARCHAR";
                tuple[2] = "" + Integer.MAX_VALUE;
        break;
      case CLOB:
      case CHAR:
      case CHARACTER:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CHAR:
          jj_consume_token(CHAR);
          jj_consume_token(LARGE);
          jj_consume_token(OBJECT);
          break;
        case CHARACTER:
          jj_consume_token(CHARACTER);
          jj_consume_token(LARGE);
          jj_consume_token(OBJECT);
          break;
        case CLOB:
          jj_consume_token(CLOB);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
                tuple[1] = "CLOB";
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPENPAREN:
          SqlPrecision(tuple);
          break;
        default:
          ;
        }
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void SqlBinaryStringType(Object[] tuple) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BYTE:
      jj_consume_token(BYTE);
                tuple[1] = "BYTE";
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPENPAREN:
        SqlPrecision(tuple);
        break;
      default:
        ;
      }
      break;
    default:
      if (jj_2_31(2)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BINARY:
          jj_consume_token(BINARY);
          break;
        case VARBINARY:
          jj_consume_token(VARBINARY);
          break;
        case RAW:
          jj_consume_token(RAW);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
                tuple[1] = "VARBINARY";
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPENPAREN:
          SqlPrecision(tuple);
          break;
        default:
          ;
        }
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LONG:
        case LONGVARBINARY:
        case IMAGE:
          if (jj_2_30(2)) {
            jj_consume_token(LONG);
            jj_consume_token(VARBINARY);
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case LONGVARBINARY:
              jj_consume_token(LONGVARBINARY);
              break;
            case LONG:
              jj_consume_token(LONG);
              jj_consume_token(RAW);
              break;
            case IMAGE:
              jj_consume_token(IMAGE);
              break;
            default:
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
                tuple[1] = "LONGVARBINARY";
                tuple[2] = "" + Integer.MAX_VALUE;
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case OPENPAREN:
            SqlCharLength(tuple);
            break;
          default:
            ;
          }
          break;
        case BLOB:
        case BINARY:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BINARY:
            jj_consume_token(BINARY);
            jj_consume_token(LARGE);
            jj_consume_token(OBJECT);
            break;
          case BLOB:
            jj_consume_token(BLOB);
            break;
          default:
            jj_consume_token(-1);
            throw new ParseException();
          }
                tuple[1] = "BLOB";
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case OPENPAREN:
            SqlPrecision(tuple);
            break;
          default:
            ;
          }
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
  }

  final public void SqlExactNumericType(Object[] tuple) throws ParseException {
        Integer precision = new Integer(BigDecimalType.DEFAULT_PRECISION);
        Integer scale = new Integer(BigDecimalType.DEFAULT_SCALE);
    if (jj_2_32(3)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUMERIC:
        jj_consume_token(NUMERIC);
        break;
      case DECIMAL:
        jj_consume_token(DECIMAL);
        break;
      case DEC:
        jj_consume_token(DEC);
        break;
      case NUMBER:
        jj_consume_token(NUMBER);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
                tuple[1] = "NUMERIC";
                tuple[2] = precision.toString();
                tuple[3] = scale.toString();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPENPAREN:
        SqlPrecisionAndScale(tuple);
        break;
      default:
        ;
      }
                precision = Integer.valueOf(tuple[2].toString());
                scale = Integer.valueOf(tuple[3].toString());
                if (scale.compareTo(precision) > 0) {
                    {if (true) throw new AxionSqlParseException("scale value exceeds precision value", 22003);}
                } else if (precision.compareTo(new Integer(BigDecimalType.MAX_PRECISION)) > 0) {
                    {if (true) throw new AxionSqlParseException("precision value exceeds maximum ("
                        + BigDecimalType.MAX_PRECISION + ")", 22003);}
                }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT:
      case INTEGER:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INTEGER:
          jj_consume_token(INTEGER);
          break;
        case INT:
          jj_consume_token(INT);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
                tuple[1] = "INTEGER";
        break;
      case SMALLINT:
      case SHORT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SMALLINT:
          jj_consume_token(SMALLINT);
          break;
        case SHORT:
          jj_consume_token(SHORT);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
                tuple[1] = "SHORT";
        break;
      case BIGINT:
        jj_consume_token(BIGINT);
                tuple[1] = "BIGINT";
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void SqlApproximateNumericType(Object[] tuple) throws ParseException {
    if (jj_2_33(3)) {
      jj_consume_token(FLOAT);
                tuple[1] = "FLOAT";
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPENPAREN:
        SqlPrecision(tuple);
        break;
      default:
        ;
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REAL:
        jj_consume_token(REAL);
                tuple[1] = "FLOAT";
        break;
      case DOUBLE:
        jj_consume_token(DOUBLE);
                tuple[1] = "DOUBLE";
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void SqlBooleanType(Object[] tuple) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOOLEAN:
      jj_consume_token(BOOLEAN);
      break;
    case BIT:
      jj_consume_token(BIT);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
                tuple[1] = "BOOLEAN";
  }

  final public void SqlDataTimeType(Object[] tuple) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DATE:
      jj_consume_token(DATE);
                tuple[1] = "DATE";
      break;
    case TIME:
      jj_consume_token(TIME);
                tuple[1] = "TIME";
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPENPAREN:
        SqlPrecision(tuple);
        break;
      default:
        ;
      }
      break;
    case TIMESTAMP:
      jj_consume_token(TIMESTAMP);
                tuple[1] = "TIMESTAMP";
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPENPAREN:
        SqlPrecision(tuple);
        break;
      default:
        ;
      }
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void SqlJavaObjectType(Object[] tuple) throws ParseException {
    jj_consume_token(JAVA_OBJECT);
                tuple[1] = "JAVA_OBJECT";
  }

  final public void SqlUserDefinedType(Object[] tuple) throws ParseException {
    tuple[1] = SqlClassName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPENPAREN:
      SqlPrecisionAndScale(tuple);
      break;
    default:
      ;
    }
  }

  final public void SqlCharLength(Object[] tuple) throws ParseException {
    jj_consume_token(OPENPAREN);
    tuple[2] = SqlPositiveInteger();
    jj_consume_token(CLOSEPAREN);
  }

  final public void SqlPrecisionAndScale(Object[] tuple) throws ParseException {
    jj_consume_token(OPENPAREN);
    tuple[2] = SqlPositiveInteger();
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        break label_11;
      }
      jj_consume_token(COMMA);
      tuple[3] = SqlUnsignedInteger();
    }
    jj_consume_token(CLOSEPAREN);
  }

  final public void SqlPrecision(Object[] tuple) throws ParseException {
    jj_consume_token(OPENPAREN);
    tuple[2] = SqlUnsignedInteger();
    jj_consume_token(CLOSEPAREN);
  }

  final public String SqlPositiveInteger() throws ParseException {
        String valStr = null;
    valStr = SqlUnsignedInteger();
            int val = (valStr != null) ? Integer.valueOf(valStr).intValue() : -1;
              if (val == 0) {
                  {if (true) throw new AxionSqlParseException("value must be a positive integer", 22003);}
              }
              {if (true) return valStr;}
    throw new Error("Missing return statement in function");
  }

  final public String SqlUnsignedInteger() throws ParseException {
        Token t = null;
    t = jj_consume_token(INTEGER_LITERAL);
            if(t != null){
                {if (true) return t.image;}
            }
            {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  final public ColumnIdentifier SqlColumnRef() throws ParseException {
        String column = null;
    column = SqlValueTerm();
            {if (true) return new ColumnIdentifier(column);}
    throw new Error("Missing return statement in function");
  }

  final public Selectable SqlCase() throws ParseException {
        List   caseargs = new ArrayList();
        List   whenargs = null;
        List   eqargs = null;

        Selectable condition = null;
        Selectable caseOperand = null;
        Selectable whenArg = null;
        Selectable thenArg = null;
        Selectable elseArg = null;

        FunctionIdentifier whenFn = null;
        FunctionIdentifier caseFn = null;
        FunctionIdentifier eqFn = null;
        FunctionIdentifier orFn = null;
    jj_consume_token(CASE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CAST:
    case CASE:
    case CURRENT_TIMESTAMP:
    case CURRENT_DATE:
    case CURRENT_TIME:
    case DAY:
    case EXISTS:
    case EXTRACT:
    case FALSE:
    case HOUR:
    case MINUTE:
    case MILLISECOND:
    case MONTH:
    case NOT:
    case NULL:
    case POSITION:
    case QUARTER:
    case SECOND:
    case SUBSTRING:
    case SYSDATE:
    case TRIM:
    case TRUE:
    case WEEK:
    case YEAR:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case ID:
    case OPENPAREN:
    case ASTERISK:
    case MINUS:
    case QUESTIONMARK:
    case START_QUOTED_IDENTIFIER:
      caseOperand = SqlSelectable();
      label_12:
      while (true) {
        jj_consume_token(WHEN);
        whenArg = SqlSelectable();
                            eqargs = new ArrayList();
                            eqargs.add(caseOperand);
                            eqargs.add(whenArg);
                            eqFn = new FunctionIdentifier("=", eqargs);

                            whenargs = new ArrayList();
                            whenargs.add(eqFn);
        label_13:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            break label_13;
          }
          jj_consume_token(COMMA);
          whenArg = SqlSelectable();
                                eqargs = new ArrayList();
                                eqargs.add(caseOperand);
                                eqargs.add(whenArg);
                                eqFn = new FunctionIdentifier("=", eqargs);

                                List   orargs = new ArrayList();
                                orargs.add(eqFn);
                                orargs.add(whenargs.get(0));
                                orFn = new FunctionIdentifier("OR", orargs);
                                whenargs.set(0, orFn);
        }
        jj_consume_token(THEN);
        thenArg = SqlSelectable();
                            whenargs.add(thenArg);
                            whenFn = new FunctionIdentifier("IFTHEN", whenargs);
                            caseargs.add(whenFn);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WHEN:
          ;
          break;
        default:
          break label_12;
        }
      }
      break;
    case WHEN:
      label_14:
      while (true) {
        jj_consume_token(WHEN);
        condition = SqlWhereOr();
                            whenargs = new ArrayList();
                            whenargs.add(condition);
        label_15:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            break label_15;
          }
          jj_consume_token(COMMA);
          condition = SqlWhereOr();
                                List   orargs = new ArrayList();
                                orargs.add(condition);
                                orargs.add(whenargs.get(0));
                                orFn = new FunctionIdentifier("OR", orargs);
                                whenargs.set(0, orFn);
        }
        jj_consume_token(THEN);
        thenArg = SqlSelectable();
                            whenargs.add(thenArg);
                            whenFn = new FunctionIdentifier("IFTHEN", whenargs);
                            caseargs.add(whenFn);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WHEN:
          ;
          break;
        default:
          break label_14;
        }
      }
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      jj_consume_token(ELSE);
      elseArg = SqlSelectable();
                caseargs.add(elseArg);
      break;
    default:
      ;
    }
    jj_consume_token(END);
            caseFn = new FunctionIdentifier("COALESCE", caseargs);
            // caseFn.setAlias("CASEWHEN");
            {if (true) return (caseFn);}
    throw new Error("Missing return statement in function");
  }

  final public Selectable SqlPseudoColumn() throws ParseException {
        List fnargs = null;
        FunctionIdentifier fn = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CURRENT_TIMESTAMP:
    case SYSDATE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SYSDATE:
        jj_consume_token(SYSDATE);
        break;
      case CURRENT_TIMESTAMP:
        jj_consume_token(CURRENT_TIMESTAMP);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
                fn = new FunctionIdentifier("NOW",Collections.EMPTY_LIST);
                fn.setAlias("CURRENT_TIMESTAMP");
                {if (true) return fn;}
      break;
    case CURRENT_DATE:
      jj_consume_token(CURRENT_DATE);
            fnargs = new ArrayList();
            fnargs.add(new FunctionIdentifier("NOW",Collections.EMPTY_LIST));
            fnargs.add(new Literal("DATE"));
            fn = new FunctionIdentifier("CASTAS",fnargs);
            fn.setAlias("CURRENT_DATE");
            {if (true) return fn;}
      break;
    case CURRENT_TIME:
      jj_consume_token(CURRENT_TIME);
            fnargs = new ArrayList();
            fnargs.add(new FunctionIdentifier("NOW",Collections.EMPTY_LIST));
            fnargs.add(new Literal("TIME"));
            fn = new FunctionIdentifier("CASTAS",fnargs);
            fn.setAlias("CURRENT_TIME");
            {if (true) return fn;}
      break;
    case DAY:
      jj_consume_token(DAY);
                         {if (true) return new Literal("DAY");}
      break;
    case MONTH:
      jj_consume_token(MONTH);
                         {if (true) return new Literal("MONTH");}
      break;
    case YEAR:
      jj_consume_token(YEAR);
                         {if (true) return new Literal("YEAR");}
      break;
    case HOUR:
      jj_consume_token(HOUR);
                         {if (true) return new Literal("HOUR");}
      break;
    case MINUTE:
      jj_consume_token(MINUTE);
                         {if (true) return new Literal("MINUTE");}
      break;
    case SECOND:
      jj_consume_token(SECOND);
                         {if (true) return new Literal("SECOND");}
      break;
    case WEEK:
      jj_consume_token(WEEK);
                         {if (true) return new Literal("WEEK");}
      break;
    case QUARTER:
      jj_consume_token(QUARTER);
                            {if (true) return new Literal("QUARTER");}
      break;
    case MILLISECOND:
      jj_consume_token(MILLISECOND);
                            {if (true) return new Literal("MILLISECOND");}
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Selectable SqlCastAs() throws ParseException {
        Selectable identifer = null;
        Object[] tuple;
        Literal literal;
        Literal precision;
        Literal scale;
        List fnargs = null;
    jj_consume_token(CAST);
    jj_consume_token(OPENPAREN);
    identifer = SqlSumExprSelectable();
    jj_consume_token(AS);
    tuple = SqlCastAsType();
    jj_consume_token(CLOSEPAREN);
            literal = new Literal(tuple[1]);
            fnargs = new ArrayList();
            fnargs.add(identifer);
            fnargs.add(literal);

            if (tuple[2] != null) {
                precision = new Literal(tuple[2]);
                fnargs.add(precision);
            }

            if (tuple[3] != null) {
                scale = new Literal(tuple[3]);
                fnargs.add(scale);
            }

            {if (true) return new FunctionIdentifier("CASTAS",fnargs);}
    throw new Error("Missing return statement in function");
  }

  final public Object[] SqlCastAsType() throws ParseException {
        Object[] tuple = new Object[5];
    if (jj_2_34(2)) {
      SqlCharStringType(tuple);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BYTE:
      case BLOB:
      case LONG:
      case RAW:
      case BINARY:
      case VARBINARY:
      case LONGVARBINARY:
      case IMAGE:
        SqlBinaryStringType(tuple);
        break;
      case INT:
      case BIGINT:
      case NUMERIC:
      case NUMBER:
      case DECIMAL:
      case DEC:
      case INTEGER:
      case SMALLINT:
      case SHORT:
        SqlExactNumericType(tuple);
        break;
      case REAL:
      case FLOAT:
      case DOUBLE:
        SqlApproximateNumericType(tuple);
        break;
      case BIT:
      case BOOLEAN:
        SqlBooleanType(tuple);
        break;
      case DATE:
      case TIME:
      case TIMESTAMP:
        SqlDataTimeType(tuple);
        break;
      case JAVA_OBJECT:
        SqlJavaObjectType(tuple);
        break;
      case ID:
        SqlUserDefinedType(tuple);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
            {if (true) return tuple;}
    throw new Error("Missing return statement in function");
  }

  final public Selectable SqlSubString() throws ParseException {
        Selectable charValueExpr = null;
        String startPos = null;
        String strLength = null;
        List fnargs = null;
    jj_consume_token(SUBSTRING);
    jj_consume_token(OPENPAREN);
    charValueExpr = SqlSumExprSelectable();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FROM:
      jj_consume_token(FROM);
      break;
    case COMMA:
      jj_consume_token(COMMA);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
    startPos = SqlUnsignedInteger();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FOR:
      jj_consume_token(FOR);
      break;
    case COMMA:
      jj_consume_token(COMMA);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
    strLength = SqlUnsignedInteger();
    jj_consume_token(CLOSEPAREN);
            fnargs = new ArrayList();
            fnargs.add(charValueExpr);
            fnargs.add(new Literal(startPos));
            fnargs.add(new Literal(strLength));
            {if (true) return new FunctionIdentifier("SUBSTRING",fnargs);}
    throw new Error("Missing return statement in function");
  }

  final public Selectable SqlExtract() throws ParseException {
        Selectable datePart = null;
        Selectable dateSrc = null;
        List fnargs = null;
    jj_consume_token(EXTRACT);
    jj_consume_token(OPENPAREN);
    datePart = SqlSumExprSelectable();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FROM:
      jj_consume_token(FROM);
      break;
    case COMMA:
      jj_consume_token(COMMA);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
    dateSrc = SqlSumExprSelectable();
    jj_consume_token(CLOSEPAREN);
            fnargs = new ArrayList();
            fnargs.add(datePart);
            fnargs.add(dateSrc);
            {if (true) return new FunctionIdentifier("EXTRACT",fnargs);}
    throw new Error("Missing return statement in function");
  }

  final public Selectable SqlPosition() throws ParseException {
        Selectable charValueExpr1 = null;
        Selectable charValueExpr2 = null;
        List fnargs = null;
    jj_consume_token(POSITION);
    jj_consume_token(OPENPAREN);
    charValueExpr1 = SqlSumExprSelectable();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IN:
      jj_consume_token(IN);
      break;
    case COMMA:
      jj_consume_token(COMMA);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
    charValueExpr2 = SqlSumExprSelectable();
    jj_consume_token(CLOSEPAREN);
            fnargs = new ArrayList();
            fnargs.add(charValueExpr2);
            fnargs.add(charValueExpr1);
            {if (true) return new FunctionIdentifier("POSITION",fnargs);}
    throw new Error("Missing return statement in function");
  }

  final public Selectable SqlTrim() throws ParseException {
        Selectable trimSource = null;
        Selectable trimChar = null;
        int type = 3;
        List fnargs = null;
    jj_consume_token(TRIM);
    jj_consume_token(OPENPAREN);
    if (jj_2_35(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOTH:
      case LEADING:
      case TRAILING:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LEADING:
          jj_consume_token(LEADING);
                                  type = 1;
          break;
        case TRAILING:
          jj_consume_token(TRAILING);
                                  type = 2;
          break;
        case BOTH:
          jj_consume_token(BOTH);
                                  type = 3;
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CAST:
      case CASE:
      case CURRENT_TIMESTAMP:
      case CURRENT_DATE:
      case CURRENT_TIME:
      case DAY:
      case EXISTS:
      case EXTRACT:
      case FALSE:
      case HOUR:
      case MINUTE:
      case MILLISECOND:
      case MONTH:
      case NULL:
      case POSITION:
      case QUARTER:
      case SECOND:
      case SUBSTRING:
      case SYSDATE:
      case TRIM:
      case TRUE:
      case WEEK:
      case YEAR:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case STRING_LITERAL:
      case ID:
      case OPENPAREN:
      case ASTERISK:
      case MINUS:
      case QUESTIONMARK:
      case START_QUOTED_IDENTIFIER:
        trimChar = SqlSumExprSelectable();
        break;
      default:
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FROM:
        jj_consume_token(FROM);
        break;
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } else {
      ;
    }
    trimSource = SqlSumExprSelectable();
    jj_consume_token(CLOSEPAREN);
            fnargs = new ArrayList();
            fnargs.add(new Literal(new Integer(type)));
            fnargs.add(trimSource);
            if (trimChar != null) {
                fnargs.add(trimChar);
            }
            {if (true) return new FunctionIdentifier("TRIM",fnargs);}
    throw new Error("Missing return statement in function");
  }

  final public Selectable SqlFunction() throws ParseException {
        String name = null;
        List fnargs = null;
        Selectable sel = null;
    name = SqlUnquotedId();
    fnargs = SqlFunctionArgs(name);
                  sel = new FunctionIdentifier(name, fnargs);
            {if (true) return sel;}
    throw new Error("Missing return statement in function");
  }

  final public List SqlFunctionArgs(String name) throws ParseException {
        List args = new ArrayList();
        String qualifier = null;
        String fn = null;
        Token t = null;
    jj_consume_token(OPENPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ALL:
    case DISTINCT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DISTINCT:
        t = jj_consume_token(DISTINCT);
        break;
      case ALL:
        t = jj_consume_token(ALL);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
                fn = name.toUpperCase();
                if(fn.equals("AVG") || fn.equals("SUM") || fn.equals("MAX") || fn.equals("MIN") || fn.equals("COUNT")) {
                    qualifier = t.image.toUpperCase();
                } else {
                    {if (true) throw new ParseException("DISTINCT is not allowed for scalar function: " + name);}
                }
      break;
    default:
      ;
    }
    args = SqlSelectCols();
    jj_consume_token(CLOSEPAREN);
            if(qualifier != null){
                args.add(new Literal(qualifier, new CharacterType(qualifier.length())));
            }
            {if (true) return args;}
    throw new Error("Missing return statement in function");
  }

  final public Selectable SqlSumExprSelectable() throws ParseException {
        FunctionIdentifier parent = null;
        Selectable left = null;
        Selectable right = null;
        String function = null;
        String fnalias = null;
        Selectable result = null;
    left = SqlProductExprSelectable();
            result = left;
    label_16:
    while (true) {
      if (jj_2_36(2)) {
        ;
      } else {
        break label_16;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        jj_consume_token(PLUS);
                             function = "+";  fnalias = "ADD";
        break;
      case MINUS:
        jj_consume_token(MINUS);
                             function = "-";  fnalias = "SUBTRACT";
        break;
      case CONCAT:
        jj_consume_token(CONCAT);
                             function = "||"; fnalias = "CONCAT";
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      right = SqlProductExprSelectable();
                parent = new FunctionIdentifier(function);
                parent.setAlias(fnalias);
                parent.addArgument(left);
                parent.addArgument(right);
                left = parent;
                result = parent;
    }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public Selectable SqlProductExprSelectable() throws ParseException {
        FunctionIdentifier parent = null;
        Selectable left = null;
        Selectable right = null;
        String function = null;
        String fnalias = null;
        Selectable result = null;
    left = SqlSelectableElements();
            result = left;
    label_17:
    while (true) {
      if (jj_2_37(2)) {
        ;
      } else {
        break label_17;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASTERISK:
        jj_consume_token(ASTERISK);
                          function = "*"; fnalias = "MULTIPLY";
        break;
      case SLASH:
        jj_consume_token(SLASH);
                          function = "/"; fnalias = "DIVIDE";
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      right = SqlSelectableElements();
                parent = new FunctionIdentifier(function);
                parent.setAlias(fnalias);
                parent.addArgument(left);
                parent.addArgument(right);
                left = parent;
                result = parent;
    }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public List SqlLiteralList() throws ParseException {
        List result = new ArrayList();
        Object cur = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FALSE:
    case NULL:
    case TRUE:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case ASTERISK:
    case MINUS:
      cur = SqlLiteral();
      break;
    case QUESTIONMARK:
      cur = SqlBindVar();
      break;
    case OPENPAREN:
      cur = SqlSelectAsScalarValue();
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
            result.add(cur);
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        break label_18;
      }
      jj_consume_token(COMMA);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FALSE:
      case NULL:
      case TRUE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case STRING_LITERAL:
      case ASTERISK:
      case MINUS:
        cur = SqlLiteral();
        break;
      case QUESTIONMARK:
        cur = SqlBindVar();
        break;
      case OPENPAREN:
        cur = SqlSelectAsScalarValue();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
                result.add(cur);
    }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public String SqlLValue() throws ParseException {
        String s = null;
    s = SqlValueTerm();
            {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  final public Literal SqlLiteral() throws ParseException {
        Literal literal = null;
        Token t = null;
        boolean minus = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRING_LITERAL:
      t = jj_consume_token(STRING_LITERAL);
                // trim off the open and close quotes
                String trimmed = t.image.substring(1, t.image.length() - 1);

                // replace all '' with '
                String result = replace(trimmed,"''","'");
                literal = new Literal(result, new CharacterType(result.length()));
      break;
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case MINUS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MINUS:
        jj_consume_token(MINUS);
                            minus = true;
        break;
      default:
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
        t = jj_consume_token(INTEGER_LITERAL);
                            {
                                BigDecimal value = new BigDecimal((minus ? "-" : "") + t.image);
                                int precision = t.image.length();
                                literal = new Literal(value, new BigDecimalType(precision, 0));
                            }
        break;
      case FLOATING_POINT_LITERAL:
        t = jj_consume_token(FLOATING_POINT_LITERAL);
                            BigDecimal value = new BigDecimal((minus ? "-" : "") + t.image);
                            int precision = value.unscaledValue().abs().toString().length();
                            int scale = value.scale();
                            literal = new Literal(value, new BigDecimalType(precision, scale));
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    case NULL:
      jj_consume_token(NULL);
                literal = new Literal(null);
      break;
    case TRUE:
      jj_consume_token(TRUE);
                literal = new Literal(Boolean.TRUE,new BooleanType());
      break;
    case FALSE:
      jj_consume_token(FALSE);
                literal = new Literal(Boolean.FALSE,new BooleanType());
      break;
    case ASTERISK:
      jj_consume_token(ASTERISK);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
            {if (true) return literal;}
    throw new Error("Missing return statement in function");
  }

  final public String SqlValueTerm() throws ParseException {
        StringBuffer buffer = new StringBuffer();
        String id = null;
        Token t = null;
    id = SqlQuotedId();
            buffer.append(id);
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        ;
        break;
      default:
        break label_19;
      }
      t = jj_consume_token(DOT);
                  buffer.append(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
      case START_QUOTED_IDENTIFIER:
        id = SqlQuotedId();
                    buffer.append(id);
        break;
      case ASTERISK:
        jj_consume_token(ASTERISK);
                    buffer.append("*");
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
            {if (true) return buffer.toString();}
    throw new Error("Missing return statement in function");
  }

  final public String SqlClassName() throws ParseException {
        StringBuffer buffer = new StringBuffer();
        Token t = null;
    t = jj_consume_token(ID);
            buffer.append(t.image);
    label_20:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        ;
        break;
      default:
        break label_20;
      }
      t = jj_consume_token(DOT);
                  buffer.append(t.image);
      t = jj_consume_token(ID);
                    buffer.append(t.image);
    }
            {if (true) return buffer.toString();}
    throw new Error("Missing return statement in function");
  }

  final public Selectable SqlSelectable() throws ParseException {
        Selectable sel = null;
    sel = SqlWhereOr();
            {if (true) return sel;}
    throw new Error("Missing return statement in function");
  }

  final public Selectable SqlSelectAsScalarValue() throws ParseException {
        AxionCommand select = null;
    jj_consume_token(OPENPAREN);
    select = SqlSubSelect();
    jj_consume_token(CLOSEPAREN);
            ((SubSelectCommand)select).setEvaluteAsScalarValue();
            {if (true) return (Selectable)select;}
    throw new Error("Missing return statement in function");
  }

  final public Selectable SqlSelectableElements() throws ParseException {
        Selectable sel = null;
    if (jj_2_39(2)) {
      jj_consume_token(OPENPAREN);
      sel = SqlWhereOr();
      jj_consume_token(CLOSEPAREN);
                {if (true) return sel;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CAST:
      case CASE:
      case CURRENT_TIMESTAMP:
      case CURRENT_DATE:
      case CURRENT_TIME:
      case DAY:
      case EXISTS:
      case EXTRACT:
      case FALSE:
      case HOUR:
      case MINUTE:
      case MILLISECOND:
      case MONTH:
      case NULL:
      case POSITION:
      case QUARTER:
      case SECOND:
      case SUBSTRING:
      case SYSDATE:
      case TRIM:
      case TRUE:
      case WEEK:
      case YEAR:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case STRING_LITERAL:
      case ID:
      case OPENPAREN:
      case ASTERISK:
      case MINUS:
      case QUESTIONMARK:
      case START_QUOTED_IDENTIFIER:
        if (jj_2_38(2)) {
          sel = SqlFunction();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ID:
          case START_QUOTED_IDENTIFIER:
            sel = SqlColumnRef();
            break;
          case CAST:
            sel = SqlCastAs();
            break;
          case SUBSTRING:
            sel = SqlSubString();
            break;
          case POSITION:
            sel = SqlPosition();
            break;
          case EXTRACT:
            sel = SqlExtract();
            break;
          case TRIM:
            sel = SqlTrim();
            break;
          case FALSE:
          case NULL:
          case TRUE:
          case INTEGER_LITERAL:
          case FLOATING_POINT_LITERAL:
          case STRING_LITERAL:
          case ASTERISK:
          case MINUS:
            sel = SqlLiteral();
            break;
          case QUESTIONMARK:
            sel = SqlBindVar();
            break;
          case CASE:
            sel = SqlCase();
            break;
          case CURRENT_TIMESTAMP:
          case CURRENT_DATE:
          case CURRENT_TIME:
          case DAY:
          case HOUR:
          case MINUTE:
          case MILLISECOND:
          case MONTH:
          case QUARTER:
          case SECOND:
          case SYSDATE:
          case WEEK:
          case YEAR:
            sel = SqlPseudoColumn();
            break;
          case EXISTS:
            sel = SqlExistsClause();
            break;
          case OPENPAREN:
            sel = SqlSelectAsScalarValue();
            break;
          default:
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
            {if (true) return sel;}
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public List SqlSelectList() throws ParseException {
        List list = new ArrayList();
        Selectable curCol = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CAST:
    case CASE:
    case CURRENT_TIMESTAMP:
    case CURRENT_DATE:
    case CURRENT_TIME:
    case DAY:
    case EXISTS:
    case EXTRACT:
    case FALSE:
    case HOUR:
    case MINUTE:
    case MILLISECOND:
    case MONTH:
    case NOT:
    case NULL:
    case POSITION:
    case QUARTER:
    case SECOND:
    case SUBSTRING:
    case SYSDATE:
    case TRIM:
    case TRUE:
    case WEEK:
    case YEAR:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case STRING_LITERAL:
    case ID:
    case OPENPAREN:
    case ASTERISK:
    case MINUS:
    case QUESTIONMARK:
    case START_QUOTED_IDENTIFIER:
      curCol = SqlSelectClauseElement();
      break;
    case NEXT:
      curCol = SqlNextValueFor();
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
            list.add(curCol);
    label_21:
    while (true) {
      if (jj_2_40(2)) {
        ;
      } else {
        break label_21;
      }
      jj_consume_token(COMMA);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CAST:
      case CASE:
      case CURRENT_TIMESTAMP:
      case CURRENT_DATE:
      case CURRENT_TIME:
      case DAY:
      case EXISTS:
      case EXTRACT:
      case FALSE:
      case HOUR:
      case MINUTE:
      case MILLISECOND:
      case MONTH:
      case NOT:
      case NULL:
      case POSITION:
      case QUARTER:
      case SECOND:
      case SUBSTRING:
      case SYSDATE:
      case TRIM:
      case TRUE:
      case WEEK:
      case YEAR:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case STRING_LITERAL:
      case ID:
      case OPENPAREN:
      case ASTERISK:
      case MINUS:
      case QUESTIONMARK:
      case START_QUOTED_IDENTIFIER:
        curCol = SqlSelectClauseElement();
        break;
      case NEXT:
        curCol = SqlNextValueFor();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
                  list.add(curCol);
    }
            Iterator itr = list.iterator();
            FunctionIdentifier function = null;
            String fName = null;
            Object obj = null;
            Map aliasSuffixCounterMap = new HashMap();

            while (itr.hasNext()){
                obj = itr.next();
                if (obj instanceof FunctionIdentifier){
                    function = (FunctionIdentifier) obj;
                    fName = function.getName().toUpperCase();

                    // this will allow us to display function alias as label
                    if (function.getAlias() == null) {
                        // Get unique name so that we do not end-up with same alias if same function 
                        // is used more than once.
                        function.setAlias(getUniqueAliasName(aliasSuffixCounterMap, fName));
                    }
                }
            }
            {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

  final public Selectable SqlSelectClauseElement() throws ParseException {
        Selectable curCol = null;
        String id = null;
    curCol = SqlSelectable();
    if (jj_2_41(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AS:
        jj_consume_token(AS);
        break;
      default:
        ;
      }
      id = SqlQuotedId();

    } else {
      ;
    }
            if(curCol instanceof FunctionIdentifier){
                FunctionIdentifier fn = (FunctionIdentifier)curCol;
                String fName = fn.getName().toUpperCase();
                if(fName.equals("AND") || fName.equals("OR")){
                     {if (true) throw new ParseException("Branch Functions not allowed here");}
                }

                if(fName.equals("<") || fName.equals(">") || fName.equals("=") || fName.equals("!=") || fName.equals(">=") || fName.equals("<=")){
                     {if (true) throw new ParseException("Comparison Functions not allowed here");}
                }

            }

            if(id != null){
                if(curCol instanceof ColumnIdentifier){
                    ((ColumnIdentifier)curCol).setAlias(id);
                }

                if(curCol instanceof FunctionIdentifier){
                    ((FunctionIdentifier)curCol).setAlias(id);
                }

                if(curCol instanceof Literal){
                    ((Literal)curCol).setAlias(id);
                }

                if(curCol instanceof SubSelectCommand){
                    ((SubSelectCommand)curCol).setAlias(id);
                }
            }
            {if (true) return curCol;}
    throw new Error("Missing return statement in function");
  }

  final public TableIdentifier SqlTableRef() throws ParseException {
        String name = null;
        String alias = null;
    name = SqlQuotedId();
    if (jj_2_42(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AS:
        jj_consume_token(AS);
        break;
      default:
        ;
      }
      alias = SqlQuotedId();
    } else {
      ;
    }
            {if (true) return new TableIdentifier(name, alias);}
    throw new Error("Missing return statement in function");
  }

    // ----------------------------------------------------------------------------
    // ORDER BY CLAUSE
    // ----------------------------------------------------------------------------
  final public List SqlOrderBy() throws ParseException {
       List result = null;
    jj_consume_token(ORDER);
    jj_consume_token(BY);
    result = SqlOrderByList();
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public OrderNode SqlOrderByElem() throws ParseException {
        Selectable sel = null;
        boolean ascending = true;
    sel = SqlSelectableElements();
    if (jj_2_43(2)) {
      ascending = SqlOrderDirection();
    } else {
      ;
    }
            {if (true) return new OrderNode(sel, !ascending);}
    throw new Error("Missing return statement in function");
  }

  final public List SqlOrderByList() throws ParseException {
        List result = new ArrayList();
        OrderNode cur = null;
    cur = SqlOrderByElem();
            result.add(cur);
    label_22:
    while (true) {
      if (jj_2_44(2)) {
        ;
      } else {
        break label_22;
      }
      jj_consume_token(COMMA);
      cur = SqlOrderByElem();
                result.add(cur);
    }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public boolean SqlOrderDirection() throws ParseException {
       boolean ascending = true;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASC:
      jj_consume_token(ASC);
      break;
    case DESC:
      jj_consume_token(DESC);
                ascending = false;
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
            {if (true) return ascending;}
    throw new Error("Missing return statement in function");
  }

    // ----------------------------------------------------------------------------
    // GROUP BY CLAUSE
    // ----------------------------------------------------------------------------
  final public List SqlGroupBy() throws ParseException {
        List groupByCols = null;
    jj_consume_token(GROUP);
    jj_consume_token(BY);
    groupByCols = SqlGroupByList();
            {if (true) return groupByCols;}
    throw new Error("Missing return statement in function");
  }

  final public Selectable SqlGroupByElem() throws ParseException {
        Selectable sel = null;
    sel = SqlSelectableElements();
            {if (true) return sel;}
    throw new Error("Missing return statement in function");
  }

  final public List SqlGroupByList() throws ParseException {
        List result = new ArrayList();
        Selectable cur = null;
    cur = SqlGroupByElem();
            result.add(cur);
    label_23:
    while (true) {
      if (jj_2_45(2)) {
        ;
      } else {
        break label_23;
      }
      jj_consume_token(COMMA);
      cur = SqlGroupByElem();
                result.add(cur);
    }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

    // ----------------------------------------------------------------------------
    // FROM CLAUSE
    // ----------------------------------------------------------------------------
  final public FromNode SqlFrom() throws ParseException {
        FromNode node = new FromNode();
        Object curTable = null;
    curTable = SqlTableOrView();
            node.setLeft(curTable);
    if (jj_2_46(2)) {
      node = SqlGetRightFromNode(node);
                if(node.getRight() == null){
                        node = (FromNode) node.getLeft();
                } else if(node.getLeft() == null){
                        node = (FromNode) node.getRight();
                }
    } else {
      ;
    }
            {if (true) return (node);}
    throw new Error("Missing return statement in function");
  }

  final public FromNode SqlGetTraditionalFromNode(FromNode basenode) throws ParseException {
        FromNode node = null;
        FromNode temp = null;
        Object curTable = null;
    curTable = SqlTableOrView();
                temp = new FromNode();
                temp.setLeft(basenode.getLeft());
                temp.setRight(curTable);
                temp.setType(FromNode.TYPE_INNER);
                temp.setCondition(null);
                basenode.setLeft(temp);
                node = basenode;
    if (jj_2_47(2)) {
      node = SqlGetRightFromNode(basenode);
                        if(basenode.getType() != FromNode.TYPE_SINGLE) { // Found ANSI Join
                                // Give prefernce to ANSI Join and rearrange the nodes.
                                temp = new FromNode();
                                temp = (FromNode)basenode.getLeft();
                                basenode.setLeft(temp.getRight());
                                temp.setRight(basenode);
                                temp.setType(FromNode.TYPE_INNER);
                                node = temp;
                        }
    } else {
      ;
    }
                {if (true) return (node);}
    throw new Error("Missing return statement in function");
  }

  final public Object SqlGetAnsiFromNode() throws ParseException {
        FromNode node = new FromNode();
        Object curNode = null;
    curNode = SqlTableOrView();
    if (jj_2_48(2)) {
      node = SqlGetRightFromNode(node);
                   node.setLeft(curNode);
                   curNode = node;
    } else {
      ;
    }
            {if (true) return (curNode);}
    throw new Error("Missing return statement in function");
  }

  final public FromNode SqlGetRightFromNode(FromNode node) throws ParseException {
        FromNode temp = null;
    label_24:
    while (true) {
                if (temp != null) {
                    temp.setLeft(node);
                    node = temp;
                    temp = null;
                }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        node = SqlGetTraditionalFromNode(node);
        break;
      case INNER:
      case JOIN:
      case LEFT:
      case RIGHT:
        node = SqlAnsiJoin(node);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
                temp = new FromNode();
      if (jj_2_49(2)) {
        ;
      } else {
        break label_24;
      }
    }
                {if (true) return (node);}
    throw new Error("Missing return statement in function");
  }

  final public FromNode SqlAnsiJoin(FromNode node) throws ParseException {
        Selectable condition = null;
        Object tableOrNode = null;
        int curType = -1;
    curType = SqlJoinType();
                node.setType(curType);
    tableOrNode = SqlGetAnsiFromNode();
                node.setRight(tableOrNode);
    jj_consume_token(ON);
    condition = SqlWhereOr();
                node.setCondition(condition);
                {if (true) return (node);}
    throw new Error("Missing return statement in function");
  }

  final public int SqlJoinType() throws ParseException {
        int type = FromNode.TYPE_SINGLE;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFT:
      jj_consume_token(LEFT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OUTER:
        jj_consume_token(OUTER);
        break;
      default:
        ;
      }
      jj_consume_token(JOIN);
                    type = FromNode.TYPE_LEFT;
      break;
    case RIGHT:
      jj_consume_token(RIGHT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OUTER:
        jj_consume_token(OUTER);
        break;
      default:
        ;
      }
      jj_consume_token(JOIN);
                    type = FromNode.TYPE_RIGHT;
      break;
    case INNER:
    case JOIN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INNER:
        jj_consume_token(INNER);
        break;
      default:
        ;
      }
      jj_consume_token(JOIN);
                    type = FromNode.TYPE_INNER;
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
            {if (true) return (type);}
    throw new Error("Missing return statement in function");
  }

  final public Object SqlTableOrView() throws ParseException {
        TableIdentifier curTable = null;
        AxionCommand select = null;
        String id = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
    case START_QUOTED_IDENTIFIER:
      curTable = SqlTableRef();
                {if (true) return curTable;}
      break;
    case OPENPAREN:
      jj_consume_token(OPENPAREN);
      select = SqlSubSelect();
      jj_consume_token(CLOSEPAREN);
      if (jj_2_50(2)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AS:
          jj_consume_token(AS);
          break;
        default:
          ;
        }
        id = SqlQuotedId();
      } else {
        ;
      }
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
            if (id != null) {((SubSelectCommand)select).setAlias(id);}
            {if (true) return select;}
    throw new Error("Missing return statement in function");
  }

    // ----------------------------------------------------------------------------
    // WHERE CLAUSE
    // ----------------------------------------------------------------------------
  final public Selectable SqlWhere() throws ParseException {
        Selectable result = null;
    jj_consume_token(WHERE);
    result = SqlWhereOr();
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public Selectable SqlWhereOr() throws ParseException {
        FunctionIdentifier parent = null;
        Selectable left = null;
        Selectable right = null;
        Selectable result = null;
    left = SqlWhereAnd();
            result = left;
    label_25:
    while (true) {
      if (jj_2_51(2)) {
        ;
      } else {
        break label_25;
      }
      jj_consume_token(OR);
      right = SqlWhereAnd();
                parent = new FunctionIdentifier("OR");
                parent.addArgument(left);
                parent.addArgument(right);
                left = parent;
                result = parent;
    }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public Selectable SqlWhereAnd() throws ParseException {
        FunctionIdentifier parent = null;
        Selectable left = null;
        Selectable right = null;
        Selectable result = null;
    left = SqlWhereNot();
            result = left;
    label_26:
    while (true) {
      if (jj_2_52(2)) {
        ;
      } else {
        break label_26;
      }
      jj_consume_token(AND);
      right = SqlWhereNot();
                parent = new FunctionIdentifier("AND");
                parent.addArgument(left);
                parent.addArgument(right);
                left = parent;
                result = parent;
    }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public Selectable SqlWhereNot() throws ParseException {
        Selectable child = null;
    if (jj_2_53(3)) {
      jj_consume_token(NOT);
      child = SqlWhereElt();
                FunctionIdentifier fn = new FunctionIdentifier("NOT");
                fn.addArgument(child);
                {if (true) return fn;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CAST:
      case CASE:
      case CURRENT_TIMESTAMP:
      case CURRENT_DATE:
      case CURRENT_TIME:
      case DAY:
      case EXISTS:
      case EXTRACT:
      case FALSE:
      case HOUR:
      case MINUTE:
      case MILLISECOND:
      case MONTH:
      case NULL:
      case POSITION:
      case QUARTER:
      case SECOND:
      case SUBSTRING:
      case SYSDATE:
      case TRIM:
      case TRUE:
      case WEEK:
      case YEAR:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case STRING_LITERAL:
      case ID:
      case OPENPAREN:
      case ASTERISK:
      case MINUS:
      case QUESTIONMARK:
      case START_QUOTED_IDENTIFIER:
        child = SqlWhereElt();
            {if (true) return child;}
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public Selectable SqlWhereElt() throws ParseException {
        Selectable result = null;
    result = SqlCompareExpr();
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public Selectable SqlCompareExpr() throws ParseException {
        Selectable left = null;
        Selectable right = null;
        String symbol = null;
        Selectable[] endpts = null;
        Selectable result = null;
    left = SqlSumExprSelectable();
    if (jj_2_56(3)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IS:
        symbol = SqlIsClause();
                    FunctionIdentifier fid = new FunctionIdentifier(symbol);
                    fid.addArgument(left);
                    result = fid;
        break;
      case BETWEEN:
        endpts = SqlBetweenClause();
                    FunctionIdentifier between = new FunctionIdentifier("AND");
                    between.addArgument(makeLeafWhereNode(left, ">=", endpts[0]));
                    between.addArgument(makeLeafWhereNode(left, "<=", endpts[1]));
                    result = between;
        break;
      case LESS:
      case LESSEQUAL:
      case GREATER:
      case GREATEREQUAL:
      case EQUAL:
      case NOTEQUAL:
      case NOTEQUAL2:
        symbol = SqlCompareOp();
        right = SqlSumExprSelectable();
                    result = makeLeafWhereNode(left, symbol, right);
        break;
      default:
        if (jj_2_54(2)) {
          result = SqlInClause(left);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SOUNDS:
            jj_consume_token(SOUNDS);
            jj_consume_token(LIKE);
            right = SqlSumExprSelectable();
                    result = makeLeafWhereNode(left, "SOUNDSLIKE", right);
            break;
          default:
            if (jj_2_55(2)) {
              result = SqlLikeClause(left);
            } else {
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
      }
    } else {
      ;
    }
            if (result == null) {
                result = left;
            }
            {if (true) return (result);}
    throw new Error("Missing return statement in function");
  }

  final public String SqlCompareOp() throws ParseException {
        String result = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUAL:
      jj_consume_token(EQUAL);
                                      result = "=";
      break;
    case NOTEQUAL:
      jj_consume_token(NOTEQUAL);
                                      result = "!=";
      break;
    case NOTEQUAL2:
      jj_consume_token(NOTEQUAL2);
                                      result = "!=";
      break;
    case GREATER:
      jj_consume_token(GREATER);
                                      result = ">";
      break;
    case GREATEREQUAL:
      jj_consume_token(GREATEREQUAL);
                                      result = ">=";
      break;
    case LESS:
      jj_consume_token(LESS);
                                      result = "<";
      break;
    case LESSEQUAL:
      jj_consume_token(LESSEQUAL);
                                      result = "<=";
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public String SqlIsClause() throws ParseException {
        boolean foundnot = false;
    jj_consume_token(IS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);
                       foundnot = true;
      break;
    default:
      ;
    }
    jj_consume_token(NULL);
            {if (true) return (foundnot ? "ISNOTNULL" : "ISNULL");}
    throw new Error("Missing return statement in function");
  }

  final public Selectable[] SqlBetweenClause() throws ParseException {
        Selectable[] pair = new Selectable[2];
    jj_consume_token(BETWEEN);
    pair[0] = SqlSumExprSelectable();
    jj_consume_token(AND);
    pair[1] = SqlSumExprSelectable();
            {if (true) return pair;}
    throw new Error("Missing return statement in function");
  }

  final public Selectable SqlExistsClause() throws ParseException {
        AxionCommand selectCmd = null;
        ArrayList args = new ArrayList();
    jj_consume_token(EXISTS);
    jj_consume_token(OPENPAREN);
    selectCmd = SqlSubSelect();
    jj_consume_token(CLOSEPAREN);
            if(selectCmd == null){
                {if (true) throw new ParseException("Expected SELECT");}
            }
            args.add(selectCmd);
            {if (true) return new FunctionIdentifier("EXISTS", args);};
    throw new Error("Missing return statement in function");
  }

  final public Selectable SqlInClause(Selectable left) throws ParseException {
        List elements = null;
        AxionCommand cmd = null;
        boolean isNot = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);
                 isNot = true;
      break;
    default:
      ;
    }
    jj_consume_token(IN);
    jj_consume_token(OPENPAREN);
    if (jj_2_57(3)) {
      elements = SqlLiteralList();
    } else {
      cmd = SqlSubSelect();
    }
    jj_consume_token(CLOSEPAREN);
            FunctionIdentifier fn = null;
            if(isNot){
                fn  = new FunctionIdentifier("NOTIN");
            } else {
                fn  = new FunctionIdentifier("IN");
            }
            fn.addArgument(left);
            if(elements !=null) {
                for(int i=0;i<elements.size();i++) {
                    fn.addArgument((Selectable)(elements.get(i)));
                }
            } else {
                if(cmd == null){
                     {if (true) throw new ParseException("Expected SELECT or literal list");}
                }
                fn.addArgument((SubSelectCommand)cmd);
            }

            {if (true) return fn;}
    throw new Error("Missing return statement in function");
  }

  final public Selectable SqlLikeClause(Selectable left) throws ParseException {
        Selectable right = null;
        Token optionalEscapeChar = null;
        List likeArgs = new ArrayList();
        Selectable leafWhereNode = null;
        boolean isNot = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);
                 isNot = true;
      break;
    default:
      ;
    }
    jj_consume_token(LIKE);
    right = SqlSumExprSelectable();
             likeArgs.add(right);
             FunctionIdentifier like = new FunctionIdentifier("LIKE2REGEXP", likeArgs);

             List matchArgs = new ArrayList();
             matchArgs.add(left);
             matchArgs.add(like);
             FunctionIdentifier matches = new FunctionIdentifier("MATCHES", matchArgs);

             Literal troo = new Literal(Boolean.TRUE, new BooleanType());
             leafWhereNode = makeLeafWhereNode(matches, "=", troo);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ESCAPE:
      jj_consume_token(ESCAPE);
      optionalEscapeChar = jj_consume_token(STRING_LITERAL);
                // trim off the open and close quotes
                String result = optionalEscapeChar.image.substring(1, optionalEscapeChar.image.length() - 1);

                if(result.length() > 1) {
                    {if (true) throw new AxionSqlParseException("escape character must be character string of length 1", 22019);}
                }

                Literal literal = new Literal(result, new CharacterType(result.length()));
                likeArgs.add(literal);
      break;
    default:
      ;
    }
            if(isNot) {
                FunctionIdentifier notLike = new FunctionIdentifier("NOT");
                notLike.addArgument(leafWhereNode);
                {if (true) return notLike;}
            }
            {if (true) return leafWhereNode;}
    throw new Error("Missing return statement in function");
  }

  final public AxionCommand SqlSubSelect() throws ParseException {
        AxionQueryContext context = null;
    context = SqlSubSelectContext();
            if(context == null) {
                 {if (true) throw new ParseException("Invalid Sub-Query");}
            }
            {if (true) return new SubSelectCommand(context);}
    throw new Error("Missing return statement in function");
  }

  final public AxionQueryContext SqlSubSelectContext() throws ParseException {
        AxionQueryContext context = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXPLAIN:
    case SELECT:
    case OPENPAREN:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXPLAIN:
      case SELECT:
        context = SqlSelectContext();
        break;
      case OPENPAREN:
        jj_consume_token(OPENPAREN);
        context = SqlSubSelectContext();
        jj_consume_token(CLOSEPAREN);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      ;
    }
            {if (true) return context;}
    throw new Error("Missing return statement in function");
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_1();
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_2();
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_3();
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_4();
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_5();
  }

  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_6();
  }

  final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_7();
  }

  final private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_8();
  }

  final private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_9();
  }

  final private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_10();
  }

  final private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_11();
  }

  final private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_12();
  }

  final private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_13();
  }

  final private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_14();
  }

  final private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_15();
  }

  final private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_16();
  }

  final private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_17();
  }

  final private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_18();
  }

  final private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_19();
  }

  final private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_20();
  }

  final private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_21();
  }

  final private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_22();
  }

  final private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_23();
  }

  final private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_24();
  }

  final private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_25();
  }

  final private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_26();
  }

  final private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_27();
  }

  final private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_28();
  }

  final private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_29();
  }

  final private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_30();
  }

  final private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_31();
  }

  final private boolean jj_2_32(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_32();
  }

  final private boolean jj_2_33(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_33();
  }

  final private boolean jj_2_34(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_34();
  }

  final private boolean jj_2_35(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_35();
  }

  final private boolean jj_2_36(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_36();
  }

  final private boolean jj_2_37(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_37();
  }

  final private boolean jj_2_38(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_38();
  }

  final private boolean jj_2_39(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_39();
  }

  final private boolean jj_2_40(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_40();
  }

  final private boolean jj_2_41(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_41();
  }

  final private boolean jj_2_42(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_42();
  }

  final private boolean jj_2_43(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_43();
  }

  final private boolean jj_2_44(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_44();
  }

  final private boolean jj_2_45(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_45();
  }

  final private boolean jj_2_46(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_46();
  }

  final private boolean jj_2_47(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_47();
  }

  final private boolean jj_2_48(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_48();
  }

  final private boolean jj_2_49(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_49();
  }

  final private boolean jj_2_50(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_50();
  }

  final private boolean jj_2_51(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_51();
  }

  final private boolean jj_2_52(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_52();
  }

  final private boolean jj_2_53(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_53();
  }

  final private boolean jj_2_54(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_54();
  }

  final private boolean jj_2_55(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_55();
  }

  final private boolean jj_2_56(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_56();
  }

  final private boolean jj_2_57(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    return !jj_3_57();
  }

  final private boolean jj_3R_89() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_129()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_39() {
    if (jj_scan_token(OPENPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_39()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_78() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_39()) {
    jj_scanpos = xsp;
    if (jj_3R_120()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_196() {
    if (jj_scan_token(EXTRACT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(OPENPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_134() {
    if (jj_scan_token(NOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_181() {
    if (jj_3R_204()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_96() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_134()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(LIKE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_119()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_182()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_49() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_89()) {
    jj_scanpos = xsp;
    if (jj_3R_90()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_185() {
    if (jj_scan_token(OPENPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_204()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(CLOSEPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_67() {
    if (jj_3R_114()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_88() {
    Token xsp;
    if (jj_3_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_49()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_110() {
    if (jj_scan_token(UPDATE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_19() {
    if (jj_scan_token(OPENPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_36()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(CLOSEPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_170() {
    if (jj_3R_39()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_33() {
    if (jj_scan_token(FLOAT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_67()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_48() {
    if (jj_3R_88()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_7() {
    if (jj_scan_token(OPENPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_36()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(CLOSEPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_194() {
    if (jj_scan_token(SUBSTRING)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(OPENPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_65() {
    if (jj_scan_token(NUMBER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_172() {
    if (jj_3R_104()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_57() {
    if (jj_3R_101()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_64() {
    if (jj_scan_token(DEC)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_47() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_109()) {
    jj_scanpos = xsp;
    if (jj_3R_110()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_109() {
    if (jj_scan_token(DELETE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_34() {
    if (jj_3R_48()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_133() {
    if (jj_scan_token(NOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_scan_token(WITH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(NO)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_95() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_133()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(IN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(OPENPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3_57()) {
    jj_scanpos = xsp;
    if (jj_3R_181()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(CLOSEPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_25() {
    if (jj_scan_token(ON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_47()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_24() {
    if (jj_scan_token(ON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_47()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_63() {
    if (jj_scan_token(DECIMAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_47() {
    if (jj_3R_88()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_66() {
    if (jj_3R_115()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_23() {
    if (jj_scan_token(OPENPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_46()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_154() {
    if (jj_scan_token(CLOB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_62() {
    if (jj_scan_token(NUMERIC)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_200() {
    if (jj_scan_token(EXISTS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(OPENPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_151() {
    if (jj_scan_token(TEXT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_56() {
    if (jj_scan_token(STRING)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_32() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_62()) {
    jj_scanpos = xsp;
    if (jj_3R_63()) {
    jj_scanpos = xsp;
    if (jj_3R_64()) {
    jj_scanpos = xsp;
    if (jj_3R_65()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_66()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_239() {
    if (jj_scan_token(DOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_60() {
    if (jj_scan_token(RAW)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_129() {
    if (jj_3R_104()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_143() {
    if (jj_3R_145()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_211() {
    if (jj_3R_83()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_239()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_193() {
    if (jj_scan_token(CAST)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(OPENPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_136() {
    if (jj_scan_token(BETWEEN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_119()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(AND)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_55() {
    if (jj_scan_token(VARCHAR2)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_173() {
    if (jj_scan_token(NOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_150() {
    if (jj_scan_token(LONGVARCHAR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_142() {
    if (jj_scan_token(EXTERNAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_102() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_142()) {
    jj_scanpos = xsp;
    if (jj_3R_143()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_59() {
    if (jj_scan_token(VARBINARY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_210() {
    if (jj_scan_token(ASTERISK)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_27() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_102()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(TABLE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_103()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_30() {
    if (jj_scan_token(LONG)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(VARBINARY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_223() {
    if (jj_scan_token(MILLISECOND)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_135() {
    if (jj_scan_token(IS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_173()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(NULL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_222() {
    if (jj_scan_token(QUARTER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_153() {
    if (jj_scan_token(CHARACTER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(LARGE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_54() {
    if (jj_scan_token(VARCHAR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_61() {
    if (jj_3R_114()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_46() {
    if (jj_3R_88()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_221() {
    if (jj_scan_token(WEEK)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_209() {
    if (jj_scan_token(FALSE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_220() {
    if (jj_scan_token(SECOND)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_219() {
    if (jj_scan_token(MINUTE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_218() {
    if (jj_scan_token(HOUR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_58() {
    if (jj_scan_token(BINARY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_217() {
    if (jj_scan_token(YEAR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_180() {
    if (jj_scan_token(LESSEQUAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_216() {
    if (jj_scan_token(MONTH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_208() {
    if (jj_scan_token(TRUE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_179() {
    if (jj_scan_token(LESS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_215() {
    if (jj_scan_token(DAY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_178() {
    if (jj_scan_token(GREATEREQUAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_191() {
    if (jj_3R_184()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_177() {
    if (jj_scan_token(GREATER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_176() {
    if (jj_scan_token(NOTEQUAL2)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_175() {
    if (jj_scan_token(NOTEQUAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_37() {
    if (jj_3R_104()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_207() {
    if (jj_scan_token(NULL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_174() {
    if (jj_scan_token(EQUAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_3R_27()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_31() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_58()) {
    jj_scanpos = xsp;
    if (jj_3R_59()) {
    jj_scanpos = xsp;
    if (jj_3R_60()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_61()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_149() {
    if (jj_scan_token(LONG)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(VARCHAR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_230() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_137() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_174()) {
    jj_scanpos = xsp;
    if (jj_3R_175()) {
    jj_scanpos = xsp;
    if (jj_3R_176()) {
    jj_scanpos = xsp;
    if (jj_3R_177()) {
    jj_scanpos = xsp;
    if (jj_3R_178()) {
    jj_scanpos = xsp;
    if (jj_3R_179()) {
    jj_scanpos = xsp;
    if (jj_3R_180()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_214() {
    if (jj_scan_token(CURRENT_TIME)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_232() {
    if (jj_scan_token(CURRENT_TIMESTAMP)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_155() {
    if (jj_3R_114()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_53() {
    if (jj_scan_token(CHARACTER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(VARYING)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_55() {
    if (jj_3R_96()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_152() {
    if (jj_scan_token(CHAR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(LARGE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_229() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_45() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_87()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_100() {
    if (jj_scan_token(SOUNDS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(LIKE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_119()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_213() {
    if (jj_scan_token(CURRENT_DATE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_190() {
    if (jj_3R_183()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_54() {
    if (jj_3R_95()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_228() {
    if (jj_scan_token(MINUS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_112() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_152()) {
    jj_scanpos = xsp;
    if (jj_3R_153()) {
    jj_scanpos = xsp;
    if (jj_3R_154()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_155()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_148() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_190()) {
    jj_scanpos = xsp;
    if (jj_3R_191()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_231() {
    if (jj_scan_token(SYSDATE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_27() {
    if (jj_scan_token(LONG)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_57() {
    if (jj_3R_113()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_99() {
    if (jj_3R_137()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_119()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_206() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_228()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_229()) {
    jj_scanpos = xsp;
    if (jj_3R_230()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_212() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_231()) {
    jj_scanpos = xsp;
    if (jj_3R_232()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_199() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_212()) {
    jj_scanpos = xsp;
    if (jj_3R_213()) {
    jj_scanpos = xsp;
    if (jj_3R_214()) {
    jj_scanpos = xsp;
    if (jj_3R_215()) {
    jj_scanpos = xsp;
    if (jj_3R_216()) {
    jj_scanpos = xsp;
    if (jj_3R_217()) {
    jj_scanpos = xsp;
    if (jj_3R_218()) {
    jj_scanpos = xsp;
    if (jj_3R_219()) {
    jj_scanpos = xsp;
    if (jj_3R_220()) {
    jj_scanpos = xsp;
    if (jj_3R_221()) {
    jj_scanpos = xsp;
    if (jj_3R_222()) {
    jj_scanpos = xsp;
    if (jj_3R_223()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_111() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_27()) {
    jj_scanpos = xsp;
    if (jj_3R_149()) {
    jj_scanpos = xsp;
    if (jj_3R_150()) {
    jj_scanpos = xsp;
    if (jj_3R_151()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_52() {
    if (jj_scan_token(CHAR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(VARYING)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_50() {
    if (jj_scan_token(CHARACTER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_98() {
    if (jj_3R_136()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_51() {
    if (jj_3R_113()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_87() {
    if (jj_3R_78()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_205() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_29() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_52()) {
    jj_scanpos = xsp;
    if (jj_3R_53()) {
    jj_scanpos = xsp;
    if (jj_3R_54()) {
    jj_scanpos = xsp;
    if (jj_3R_55()) {
    jj_scanpos = xsp;
    if (jj_3R_56()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_57()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_144() {
    if (jj_scan_token(IF)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_49() {
    if (jj_scan_token(CHAR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_105() {
    if (jj_3R_148()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_97() {
    if (jj_3R_135()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_183() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_205()) {
    jj_scanpos = xsp;
    if (jj_3R_206()) {
    jj_scanpos = xsp;
    if (jj_3R_207()) {
    jj_scanpos = xsp;
    if (jj_3R_208()) {
    jj_scanpos = xsp;
    if (jj_3R_209()) {
    jj_scanpos = xsp;
    if (jj_3R_210()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_103() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_144()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_145()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_28() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_49()) {
    jj_scanpos = xsp;
    if (jj_3R_50()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_51()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_48() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_28()) {
    jj_scanpos = xsp;
    if (jj_3_29()) {
    jj_scanpos = xsp;
    if (jj_3R_111()) {
    jj_scanpos = xsp;
    if (jj_3R_112()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_56() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_97()) {
    jj_scanpos = xsp;
    if (jj_3R_98()) {
    jj_scanpos = xsp;
    if (jj_3R_99()) {
    jj_scanpos = xsp;
    if (jj_3_54()) {
    jj_scanpos = xsp;
    if (jj_3R_100()) {
    jj_scanpos = xsp;
    if (jj_3_55()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_40() {
    if (jj_scan_token(GROUP)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(BY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_43() {
    if (jj_scan_token(OFFSET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_105()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_22() {
    if (jj_3R_45()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_132() {
    if (jj_3R_119()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_56()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_128() {
    if (jj_scan_token(DESC)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_35() {
    if (jj_scan_token(NO)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(MINVALUE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_188() {
    if (jj_3R_185()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_187() {
    if (jj_3R_184()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_127() {
    if (jj_scan_token(ASC)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_186() {
    if (jj_3R_183()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_42() {
    if (jj_scan_token(LIMIT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_105()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_240() {
    if (jj_scan_token(WHEN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_34() {
    if (jj_scan_token(MINVALUE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_94() {
    if (jj_3R_132()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_85() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_127()) {
    jj_scanpos = xsp;
    if (jj_3R_128()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_141() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_186()) {
    jj_scanpos = xsp;
    if (jj_3R_187()) {
    jj_scanpos = xsp;
    if (jj_3R_188()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_33() {
    if (jj_scan_token(NO)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(MAXVALUE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_6() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_34()) {
    jj_scanpos = xsp;
    if (jj_3R_35()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_124() {
    if (jj_scan_token(NEXT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(VALUE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_131() {
    if (jj_3R_94()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_26() {
    if (jj_3R_48()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_237() {
    Token xsp;
    if (jj_3R_240()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_240()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_140() {
    if (jj_3R_185()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_139() {
    if (jj_3R_184()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_44() {
    if (jj_3R_46()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_138() {
    if (jj_3R_183()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_32() {
    if (jj_scan_token(MAXVALUE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_44() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_86()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_17() {
    if (jj_scan_token(ASTERISK)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_5() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_32()) {
    jj_scanpos = xsp;
    if (jj_3R_33()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_101() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_138()) {
    jj_scanpos = xsp;
    if (jj_3R_139()) {
    jj_scanpos = xsp;
    if (jj_3R_140()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_141()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3_18() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_17()) {
    jj_scanpos = xsp;
    if (jj_3R_44()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_53() {
    if (jj_scan_token(NOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_94()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_93() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_53()) {
    jj_scanpos = xsp;
    if (jj_3R_131()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_21() {
    if (jj_3R_45()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_36() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_18()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_77() {
    if (jj_scan_token(SLASH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_76() {
    if (jj_scan_token(ASTERISK)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_43() {
    if (jj_3R_85()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_86() {
    if (jj_3R_78()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_52() {
    if (jj_scan_token(AND)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_93()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_16() {
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_37() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_76()) {
    jj_scanpos = xsp;
    if (jj_3R_77()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_78()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_15() {
    if (jj_3R_42()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_14() {
    if (jj_3R_41()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_12() {
    if (jj_scan_token(HAVING)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_39()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_92() {
    if (jj_3R_93()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_52()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3_13() {
    if (jj_3R_40()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_75() {
    if (jj_3R_78()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_37()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_41() {
    if (jj_scan_token(ORDER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(BY)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_236() {
    if (jj_3R_170()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_11() {
    if (jj_3R_38()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_198() {
    if (jj_scan_token(CASE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_236()) {
    jj_scanpos = xsp;
    if (jj_3R_237()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_10() {
    if (jj_scan_token(FROM)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_37()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_84() {
    if (jj_scan_token(AS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_20() {
    if (jj_scan_token(OPENPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_36()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(CLOSEPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_42() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_84()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_83()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_31() {
    if (jj_scan_token(NO)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(MINVALUE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_74() {
    if (jj_scan_token(CONCAT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_73() {
    if (jj_scan_token(MINUS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_51() {
    if (jj_scan_token(OR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_92()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_72() {
    if (jj_scan_token(PLUS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_189() {
    if (jj_3R_83()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_30() {
    if (jj_scan_token(MINVALUE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_36() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_72()) {
    jj_scanpos = xsp;
    if (jj_3R_73()) {
    jj_scanpos = xsp;
    if (jj_3R_74()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_75()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_39() {
    if (jj_3R_92()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_51()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_184() {
    if (jj_scan_token(QUESTIONMARK)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_29() {
    if (jj_scan_token(NO)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(MAXVALUE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_4() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_30()) {
    jj_scanpos = xsp;
    if (jj_3R_31()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_244() {
    if (jj_scan_token(DISTINCT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_192() {
    if (jj_3R_211()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_119() {
    if (jj_3R_75()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_36()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_28() {
    if (jj_scan_token(MAXVALUE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_243() {
    if (jj_scan_token(ALL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_242() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_243()) {
    jj_scanpos = xsp;
    if (jj_3R_244()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_121() {
    if (jj_scan_token(ID)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_3() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_28()) {
    jj_scanpos = xsp;
    if (jj_3R_29()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_38() {
    if (jj_scan_token(WHERE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_39()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_241() {
    if (jj_scan_token(EXPLAIN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_238() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_241()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(SELECT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_242()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_36()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3_10()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3_11()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3_13()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3_14()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3_15()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3_16()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_157() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_126() {
    if (jj_scan_token(START_QUOTED_IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(QUOTED_IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_91() {
    if (jj_scan_token(AS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_125() {
    if (jj_scan_token(ID)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_50() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_91()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_83()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_82() {
    if (jj_scan_token(AS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_83() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_125()) {
    jj_scanpos = xsp;
    if (jj_3R_126()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_41() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_82()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_83()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_156() {
    if (jj_3R_157()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_147() {
    if (jj_scan_token(OPENPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_122() {
    if (jj_scan_token(OPENPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_146() {
    if (jj_3R_189()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_145() {
    if (jj_3R_83()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_123() {
    if (jj_3R_170()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_41()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_114() {
    if (jj_scan_token(OPENPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_157()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_104() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_146()) {
    jj_scanpos = xsp;
    if (jj_3R_147()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_226() {
    if (jj_scan_token(INNER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_115() {
    if (jj_scan_token(OPENPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_156()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_79() {
    if (jj_3R_121()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_122()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_203() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_226()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(JOIN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_225() {
    if (jj_scan_token(OUTER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_71() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_113() {
    if (jj_scan_token(OPENPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_9() {
    if (jj_scan_token(OPENPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_36()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(CLOSEPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_81() {
    if (jj_3R_124()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_80() {
    if (jj_3R_123()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_224() {
    if (jj_scan_token(OUTER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_118() {
    if (jj_scan_token(BOTH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_117() {
    if (jj_scan_token(TRAILING)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_235() {
    if (jj_scan_token(OPENPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_227()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(CLOSEPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_116() {
    if (jj_scan_token(LEADING)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_68() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_116()) {
    jj_scanpos = xsp;
    if (jj_3R_117()) {
    jj_scanpos = xsp;
    if (jj_3R_118()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_70() {
    if (jj_scan_token(FROM)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_69() {
    if (jj_3R_119()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_234() {
    if (jj_3R_238()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_233() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_234()) {
    jj_scanpos = xsp;
    if (jj_3R_235()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_202() {
    if (jj_scan_token(RIGHT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_225()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(JOIN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_40() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_80()) {
    jj_scanpos = xsp;
    if (jj_3R_81()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_227() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_233()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_108() {
    if (jj_3R_124()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_201() {
    if (jj_scan_token(LEFT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_224()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(JOIN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_107() {
    if (jj_3R_123()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_35() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_68()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_69()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_106() {
    if (jj_scan_token(NOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_171() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_201()) {
    jj_scanpos = xsp;
    if (jj_3R_202()) {
    jj_scanpos = xsp;
    if (jj_3R_203()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_46() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_107()) {
    jj_scanpos = xsp;
    if (jj_3R_108()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_40()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_45() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_106()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(DEFERRABLE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_197() {
    if (jj_scan_token(TRIM)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(OPENPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_204() {
    if (jj_3R_227()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_169() {
    if (jj_3R_185()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_168() {
    if (jj_3R_200()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_8() {
    if (jj_scan_token(OPENPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_36()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(CLOSEPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_167() {
    if (jj_3R_199()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_166() {
    if (jj_3R_198()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_165() {
    if (jj_3R_184()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_164() {
    if (jj_3R_183()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_163() {
    if (jj_3R_197()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_162() {
    if (jj_3R_196()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_161() {
    if (jj_3R_195()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_160() {
    if (jj_3R_194()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_159() {
    if (jj_3R_193()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_158() {
    if (jj_3R_192()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_38() {
    if (jj_3R_79()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_195() {
    if (jj_scan_token(POSITION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(OPENPAREN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_130() {
    if (jj_3R_171()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_172()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_120() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_38()) {
    jj_scanpos = xsp;
    if (jj_3R_158()) {
    jj_scanpos = xsp;
    if (jj_3R_159()) {
    jj_scanpos = xsp;
    if (jj_3R_160()) {
    jj_scanpos = xsp;
    if (jj_3R_161()) {
    jj_scanpos = xsp;
    if (jj_3R_162()) {
    jj_scanpos = xsp;
    if (jj_3R_163()) {
    jj_scanpos = xsp;
    if (jj_3R_164()) {
    jj_scanpos = xsp;
    if (jj_3R_165()) {
    jj_scanpos = xsp;
    if (jj_3R_166()) {
    jj_scanpos = xsp;
    if (jj_3R_167()) {
    jj_scanpos = xsp;
    if (jj_3R_168()) {
    jj_scanpos = xsp;
    if (jj_3R_169()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_182() {
    if (jj_scan_token(ESCAPE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_90() {
    if (jj_3R_130()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  public AxionSqlParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  //private boolean jj_semLA;

  public AxionSqlParser(java.io.InputStream stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new AxionSqlParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
  }

  public AxionSqlParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new AxionSqlParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
  }

  public AxionSqlParser(AxionSqlParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
  }

  public void ReInit(AxionSqlParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      return token;
    }
    token = oldToken;
    throw generateParseException();
  }

  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    return (jj_scanpos.kind != kind);
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  public ParseException generateParseException() {
    Token errortok = token.next;
    int line = errortok.beginLine, column = errortok.beginColumn;
    String mess = (errortok.kind == 0) ? tokenImage[0] : errortok.image;
    return new ParseException("Parse error at line " + line + ", column " + column + ".  Encountered: " + mess);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}

